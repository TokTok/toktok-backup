{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/issues/2269/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269/commits"
        },
        "html": {
            "href": "https://github.com/TokTok/c-toxcore/pull/2269"
        },
        "issue": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/issues/2269"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
        },
        "statuses": {
            "href": "https://api.github.com/repos/TokTok/c-toxcore/statuses/0a277b52ea22fe297a8487ac05a0c507a74c6480"
        }
    },
    "active_lock_reason": null,
    "additions": 19853,
    "assignee": {
        "avatar_url": "https://avatars.githubusercontent.com/u/1646057?v=4",
        "events_url": "https://api.github.com/users/JFreegman/events{/privacy}",
        "followers_url": "https://api.github.com/users/JFreegman/followers",
        "following_url": "https://api.github.com/users/JFreegman/following{/other_user}",
        "gists_url": "https://api.github.com/users/JFreegman/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/JFreegman",
        "id": 1646057,
        "login": "JFreegman",
        "node_id": "MDQ6VXNlcjE2NDYwNTc=",
        "organizations_url": "https://api.github.com/users/JFreegman/orgs",
        "received_events_url": "https://api.github.com/users/JFreegman/received_events",
        "repos_url": "https://api.github.com/users/JFreegman/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/JFreegman/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/JFreegman/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/JFreegman",
        "user_view_type": "public"
    },
    "assignees": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/1646057?v=4",
            "events_url": "https://api.github.com/users/JFreegman/events{/privacy}",
            "followers_url": "https://api.github.com/users/JFreegman/followers",
            "following_url": "https://api.github.com/users/JFreegman/following{/other_user}",
            "gists_url": "https://api.github.com/users/JFreegman/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/JFreegman",
            "id": 1646057,
            "login": "JFreegman",
            "node_id": "MDQ6VXNlcjE2NDYwNTc=",
            "organizations_url": "https://api.github.com/users/JFreegman/orgs",
            "received_events_url": "https://api.github.com/users/JFreegman/received_events",
            "repos_url": "https://api.github.com/users/JFreegman/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/JFreegman/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/JFreegman/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/JFreegman",
            "user_view_type": "public"
        }
    ],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "TokTok:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/TokTok/c-toxcore/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/TokTok/c-toxcore/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/TokTok/c-toxcore/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/TokTok/c-toxcore/branches{/branch}",
            "clone_url": "https://github.com/TokTok/c-toxcore.git",
            "collaborators_url": "https://api.github.com/repos/TokTok/c-toxcore/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/TokTok/c-toxcore/comments{/number}",
            "commits_url": "https://api.github.com/repos/TokTok/c-toxcore/commits{/sha}",
            "compare_url": "https://api.github.com/repos/TokTok/c-toxcore/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/TokTok/c-toxcore/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/TokTok/c-toxcore/contributors",
            "created_at": "2016-07-06T08:15:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/TokTok/c-toxcore/deployments",
            "description": "The future of online communications.",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/TokTok/c-toxcore/downloads",
            "events_url": "https://api.github.com/repos/TokTok/c-toxcore/events",
            "fork": true,
            "forks": 292,
            "forks_count": 292,
            "forks_url": "https://api.github.com/repos/TokTok/c-toxcore/forks",
            "full_name": "TokTok/c-toxcore",
            "git_commits_url": "https://api.github.com/repos/TokTok/c-toxcore/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/TokTok/c-toxcore/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/TokTok/c-toxcore/git/tags{/sha}",
            "git_url": "git://github.com/TokTok/c-toxcore.git",
            "has_discussions": false,
            "has_downloads": false,
            "has_issues": true,
            "has_pages": false,
            "has_projects": false,
            "has_wiki": false,
            "homepage": "https://tox.chat",
            "hooks_url": "https://api.github.com/repos/TokTok/c-toxcore/hooks",
            "html_url": "https://github.com/TokTok/c-toxcore",
            "id": 62703642,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/TokTok/c-toxcore/issues{/number}",
            "keys_url": "https://api.github.com/repos/TokTok/c-toxcore/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/TokTok/c-toxcore/labels{/name}",
            "language": "C",
            "languages_url": "https://api.github.com/repos/TokTok/c-toxcore/languages",
            "license": {
                "key": "gpl-3.0",
                "name": "GNU General Public License v3.0",
                "node_id": "MDc6TGljZW5zZTk=",
                "spdx_id": "GPL-3.0",
                "url": "https://api.github.com/licenses/gpl-3.0"
            },
            "merges_url": "https://api.github.com/repos/TokTok/c-toxcore/merges",
            "milestones_url": "https://api.github.com/repos/TokTok/c-toxcore/milestones{/number}",
            "mirror_url": null,
            "name": "c-toxcore",
            "node_id": "MDEwOlJlcG9zaXRvcnk2MjcwMzY0Mg==",
            "notifications_url": "https://api.github.com/repos/TokTok/c-toxcore/notifications{?since,all,participating}",
            "open_issues": 210,
            "open_issues_count": 210,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17427091?v=4",
                "events_url": "https://api.github.com/users/TokTok/events{/privacy}",
                "followers_url": "https://api.github.com/users/TokTok/followers",
                "following_url": "https://api.github.com/users/TokTok/following{/other_user}",
                "gists_url": "https://api.github.com/users/TokTok/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/TokTok",
                "id": 17427091,
                "login": "TokTok",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjE3NDI3MDkx",
                "organizations_url": "https://api.github.com/users/TokTok/orgs",
                "received_events_url": "https://api.github.com/users/TokTok/received_events",
                "repos_url": "https://api.github.com/users/TokTok/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/TokTok/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/TokTok/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/TokTok",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls{/number}",
            "pushed_at": "2025-01-24T18:18:40Z",
            "releases_url": "https://api.github.com/repos/TokTok/c-toxcore/releases{/id}",
            "size": 25245,
            "ssh_url": "git@github.com:TokTok/c-toxcore.git",
            "stargazers_count": 2329,
            "stargazers_url": "https://api.github.com/repos/TokTok/c-toxcore/stargazers",
            "statuses_url": "https://api.github.com/repos/TokTok/c-toxcore/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/TokTok/c-toxcore/subscribers",
            "subscription_url": "https://api.github.com/repos/TokTok/c-toxcore/subscription",
            "svn_url": "https://github.com/TokTok/c-toxcore",
            "tags_url": "https://api.github.com/repos/TokTok/c-toxcore/tags",
            "teams_url": "https://api.github.com/repos/TokTok/c-toxcore/teams",
            "topics": [
                "cryptography",
                "encryption",
                "network",
                "p2p",
                "security",
                "toxcore"
            ],
            "trees_url": "https://api.github.com/repos/TokTok/c-toxcore/git/trees{/sha}",
            "updated_at": "2025-01-24T22:05:30Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore",
            "visibility": "public",
            "watchers": 2329,
            "watchers_count": 2329,
            "web_commit_signoff_required": false
        },
        "sha": "d3819b23b3bac6445cc1654e60530c86df3fb191",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/17427091?v=4",
            "events_url": "https://api.github.com/users/TokTok/events{/privacy}",
            "followers_url": "https://api.github.com/users/TokTok/followers",
            "following_url": "https://api.github.com/users/TokTok/following{/other_user}",
            "gists_url": "https://api.github.com/users/TokTok/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/TokTok",
            "id": 17427091,
            "login": "TokTok",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjE3NDI3MDkx",
            "organizations_url": "https://api.github.com/users/TokTok/orgs",
            "received_events_url": "https://api.github.com/users/TokTok/received_events",
            "repos_url": "https://api.github.com/users/TokTok/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/TokTok/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/TokTok/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/TokTok",
            "user_view_type": "public"
        }
    },
    "body": "Commit history: https://github.com/jfreegman/toxcore/tree/ngc_jf\r\nSpec: https://toktok.ltd/spec.html#dht-group-chats\n\n<!-- Reviewable:start -->\n---\nThis change isâ€‚[<img src=\"https://reviewable.io/review_button.svg\" height=\"34\" align=\"absmiddle\" alt=\"Reviewable\"/>](https://reviewable.io/reviews/toktok/c-toxcore/2269)\n<!-- Reviewable:end -->\n",
    "changed_files": 69,
    "closed_at": "2022-09-22T17:25:34Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r846373454"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/846373454"
                }
            },
            "author_association": "MEMBER",
            "body": "No TODO for me please :).",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-04-08T18:15:57Z",
            "diff_hunk": "@@ -21,6 +21,8 @@ CPPCHECK+=(\"--suppress=missingIncludeSystem\")\n CPPCHECK+=(\"--suppress=signConversion\")\n # TODO(iphydf): Fixed in the toxav refactor PR.\n CPPCHECK+=(\"--suppress=redundantAssignment\")\n+# TODO(iphydf): False positives",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r846373454",
            "id": 846373454,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4ycqJO",
            "original_commit_id": "77f6b54a3fb96ceec261ac8da90d51e8c71bfe35",
            "original_line": 24,
            "original_position": 4,
            "original_start_line": null,
            "path": "other/analysis/run-cppcheck",
            "position": null,
            "pull_request_review_id": 936812701,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/846373454/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-04-08T18:21:05Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/846373454",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r846376765"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/846376765"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe you can make a PR with all the formatting changes (run astyle; make PR) first?",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-04-08T18:21:00Z",
            "diff_hunk": "@@ -339,7 +339,8 @@ bool ip_is_lan(const IP *ip)\n }\n \n \n-bool lan_discovery_send(const Networking_Core *net, const Broadcast_Info *broadcast, const uint8_t *dht_pk, uint16_t port)\n+bool lan_discovery_send(const Networking_Core *net, const Broadcast_Info *broadcast, const uint8_t *dht_pk,\n+                        uint16_t port)",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r846376765",
            "id": 846376765,
            "line": 343,
            "node_id": "PRRC_kwDOA7zIGs4ycq89",
            "original_commit_id": "77f6b54a3fb96ceec261ac8da90d51e8c71bfe35",
            "original_line": 343,
            "original_position": 6,
            "original_start_line": null,
            "path": "toxcore/LAN_discovery.c",
            "position": 6,
            "pull_request_review_id": 936812701,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/846376765/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-04-08T18:21:05Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/846376765",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r853608090"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/853608090"
                }
            },
            "author_association": "MEMBER",
            "body": "What needs to be done to remove this?",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-04-19T23:48:20Z",
            "diff_hunk": "@@ -35,7 +37,11 @@ typedef enum Message_Type {\n     MESSAGE_ACTION,\n } Message_Type;\n \n+// TODO(Jfreegman, Iphy): Remove this before merge",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r853608090",
            "id": 853608090,
            "line": 40,
            "node_id": "PRRC_kwDOA7zIGs4y4Qaa",
            "original_commit_id": "7b52d02d41bfe786cd9969a7bdee8f85872ce93b",
            "original_line": 40,
            "original_position": 13,
            "original_start_line": null,
            "path": "toxcore/Messenger.h",
            "position": 13,
            "pull_request_review_id": 946439183,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/853608090/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-04-19T23:51:50Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/853608090",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r853608545"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/853608545"
                }
            },
            "author_association": "MEMBER",
            "body": "Change to `/**` style comment. Same below.",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-04-19T23:48:49Z",
            "diff_hunk": "@@ -348,6 +369,19 @@ int32_t m_addfriend(Messenger *m, const uint8_t *address, const uint8_t *data, u\n non_null()\n int32_t m_addfriend_norequest(Messenger *m, const uint8_t *real_pk);\n \n+/* Initializes the friend connection and onion connection for a groupchat.",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r853608545",
            "id": 853608545,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4y4Qhh",
            "original_commit_id": "7b52d02d41bfe786cd9969a7bdee8f85872ce93b",
            "original_line": 372,
            "original_position": 68,
            "original_start_line": null,
            "path": "toxcore/Messenger.h",
            "position": null,
            "pull_request_review_id": 946439183,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/853608545/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-04-19T23:51:50Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/853608545",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r853609198"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/853609198"
                }
            },
            "author_association": "MEMBER",
            "body": "`/**`",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-04-19T23:49:32Z",
            "diff_hunk": "@@ -344,6 +363,62 @@ static int friend_received_packet(const Messenger *m, int32_t friendnumber, uint\n                                 m->friendlist[friendnumber].friendcon_id), number);\n }\n \n+/** @brief the friend connection and onion connection for a groupchat.\n+ *\n+ * @retval 0 if success.\n+ * @retval -1 if failure.\n+ */\n+bool m_create_group_connection(Messenger *m, GC_Chat *chat)\n+{\n+    random_bytes(m->rng, chat->m_group_public_key, CRYPTO_PUBLIC_KEY_SIZE);\n+\n+    const int friendcon_id = new_friend_connection(m->fr_c, chat->m_group_public_key);\n+\n+    if (friendcon_id == -1) {\n+        return false;\n+    }\n+\n+    const Friend_Conn *connection = get_conn(m->fr_c, friendcon_id);\n+\n+    if (connection == nullptr) {\n+        return false;\n+    }\n+\n+    chat->friend_connection_id = friendcon_id;\n+\n+    friend_connection_callbacks(m->fr_c, friendcon_id, MESSENGER_CALLBACK_INDEX, &m_handle_status, &m_handle_packet,\n+                                &m_handle_lossy_packet, m, chat->group_number);\n+\n+    if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {\n+        send_online_packet(m, friendcon_id);\n+    }\n+\n+    const int onion_friend_number = friend_conn_get_onion_friendnum(connection);\n+    Onion_Friend *onion_friend = onion_get_friend(m->onion_c, (uint16_t)onion_friend_number);\n+\n+    onion_friend_set_gc_public_key(onion_friend, get_chat_id(chat->chat_public_key));\n+    onion_friend_set_gc_data(onion_friend, nullptr, 0);\n+\n+    return true;\n+}\n+\n+/*",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r853609198",
            "id": 853609198,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4y4Qru",
            "original_commit_id": "7b52d02d41bfe786cd9969a7bdee8f85872ce93b",
            "original_line": 405,
            "original_position": 140,
            "original_start_line": null,
            "path": "toxcore/Messenger.c",
            "position": null,
            "pull_request_review_id": 946439183,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/853609198/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-04-19T23:51:51Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/853609198",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
                "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
                "followers_url": "https://api.github.com/users/iphydf/followers",
                "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
                "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/iphydf",
                "id": 10647936,
                "login": "iphydf",
                "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
                "organizations_url": "https://api.github.com/users/iphydf/orgs",
                "received_events_url": "https://api.github.com/users/iphydf/received_events",
                "repos_url": "https://api.github.com/users/iphydf/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/iphydf",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r861499692"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/861499692"
                }
            },
            "author_association": "MEMBER",
            "body": "can we write the next few lines a bit better?\r\nlots of \"magic\" numbers are repeated with copy and paste\r\n```2 + GC_JOIN_DATA_LENGTH```\r\n```data + 2```\r\n```data_length - 2```",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-04-29T06:50:09Z",
            "diff_hunk": "@@ -2243,6 +2329,28 @@ static int m_handle_packet(void *object, int i, const uint8_t *temp, uint16_t le\n             break;\n         }\n \n+        case PACKET_ID_INVITE_GROUPCHAT: {\n+#ifndef VANILLA_NACL\n+",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r861499692",
            "id": 861499692,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs4zWXEs",
            "original_commit_id": "545afc7f4df9a4ce45390694c4c6ff9685a172e4",
            "original_line": 2325,
            "original_position": 209,
            "original_start_line": null,
            "path": "toxcore/Messenger.c",
            "position": null,
            "pull_request_review_id": 957305953,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/861499692/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-04-29T06:50:38Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/861499692",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6833516?v=4",
                "events_url": "https://api.github.com/users/zoff99/events{/privacy}",
                "followers_url": "https://api.github.com/users/zoff99/followers",
                "following_url": "https://api.github.com/users/zoff99/following{/other_user}",
                "gists_url": "https://api.github.com/users/zoff99/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zoff99",
                "id": 6833516,
                "login": "zoff99",
                "node_id": "MDQ6VXNlcjY4MzM1MTY=",
                "organizations_url": "https://api.github.com/users/zoff99/orgs",
                "received_events_url": "https://api.github.com/users/zoff99/received_events",
                "repos_url": "https://api.github.com/users/zoff99/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zoff99/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zoff99/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zoff99",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r866285683"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/866285683"
                }
            },
            "author_association": "MEMBER",
            "body": "The api does not say how large it can be.",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-05-05T20:24:07Z",
            "diff_hunk": "@@ -3267,6 +3267,2072 @@ uint16_t tox_self_get_tcp_port(const Tox *tox, Tox_Err_Get_Port *error);\n \n /** @} */\n \n+/*******************************************************************************\n+ *\n+ * :: Group chats\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat numeric constants\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/** @{\n+ * Maximum length of a group topic.\n+ */\n+#define TOX_GROUP_MAX_TOPIC_LENGTH     512\n+\n+uint32_t tox_group_max_topic_length(void);\n+\n+/**\n+ * Maximum length of a peer part message.\n+ */\n+#define TOX_GROUP_MAX_PART_LENGTH      128\n+\n+uint32_t tox_group_max_part_length(void);\n+\n+/**\n+ * Maximum length of a group name.\n+ */\n+#define TOX_GROUP_MAX_GROUP_NAME_LENGTH 48\n+\n+uint32_t tox_group_max_group_name_length(void);\n+\n+/**\n+ * Maximum length of a group password.\n+ */\n+#define TOX_GROUP_MAX_PASSWORD_SIZE    32\n+\n+uint32_t tox_group_max_password_size(void);\n+\n+/**\n+ * Number of bytes in a group Chat ID.\n+ */\n+#define TOX_GROUP_CHAT_ID_SIZE         32\n+\n+uint32_t tox_group_chat_id_size(void);\n+\n+/**\n+ * Size of a peer public key.\n+ */\n+#define TOX_GROUP_PEER_PUBLIC_KEY_SIZE 32\n+\n+uint32_t tox_group_peer_public_key_size(void);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat state enumerators\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/**\n+ * Represents the group privacy state.\n+ */\n+typedef enum Tox_Group_Privacy_State {\n+\n+    /**\n+     * The group is considered to be public. Anyone may join the group using the Chat ID.\n+     *\n+     * If the group is in this state, even if the Chat ID is never explicitly shared\n+     * with someone outside of the group, information including the Chat ID, IP addresses,\n+     * and peer ID's (but not Tox ID's) is visible to anyone with access to a node\n+     * storing a DHT entry for the given group.\n+     */\n+    TOX_GROUP_PRIVACY_STATE_PUBLIC,\n+\n+    /**\n+     * The group is considered to be private. The only way to join the group is by having\n+     * someone in your contact list send you an invite.\n+     *\n+     * If the group is in this state, no group information (mentioned above) is present in the DHT;\n+     * the DHT is not used for any purpose at all. If a public group is set to private,\n+     * all DHT information related to the group will expire shortly.\n+     */\n+    TOX_GROUP_PRIVACY_STATE_PRIVATE,\n+\n+} Tox_Group_Privacy_State;\n+\n+\n+/**\n+ * Represents the state of the group topic lock.\n+ */\n+typedef enum Tox_Group_Topic_Lock {\n+\n+    /**\n+     * The topic lock is enabled. Only peers with the founder and moderator roles may set the topic.\n+     */\n+    TOX_GROUP_TOPIC_LOCK_ENABLED,\n+\n+    /**\n+     * The topic lock is disabled. All peers except those with the observer role may set the topic.\n+     */\n+    TOX_GROUP_TOPIC_LOCK_DISABLED,\n+\n+} Tox_Group_Topic_Lock;\n+\n+/**\n+ * Represents the group voice state, which determines which Group Roles have permission to speak\n+ * in the group chat. The voice state does not have any effect private messages or topic setting.\n+ */\n+typedef enum Tox_Group_Voice_State {\n+    /**\n+     * All group roles above Observer have permission to speak.\n+     */\n+    TOX_GROUP_VOICE_STATE_ALL,\n+\n+    /**\n+     * Moderators and Founders have permission to speak.\n+     */\n+    TOX_GROUP_VOICE_STATE_MODERATOR,\n+\n+    /**\n+     * Only the founder may speak.\n+     */\n+    TOX_GROUP_VOICE_STATE_FOUNDER,\n+} Tox_Group_Voice_State;\n+\n+/**\n+ * Represents group roles.\n+ *\n+ * Roles are hierarchical in that each role has a set of privileges plus all the privileges\n+ * of the roles below it.\n+ */\n+typedef enum Tox_Group_Role {\n+\n+    /**\n+     * May kick all other peers as well as set their role to anything (except founder).\n+     * Founders may also set the group password, toggle the privacy state, and set the peer limit.\n+     */\n+    TOX_GROUP_ROLE_FOUNDER,\n+\n+    /**\n+     * May kick and set the user and observer roles for peers below this role.\n+     * May also set the group topic.\n+     */\n+    TOX_GROUP_ROLE_MODERATOR,\n+\n+    /**\n+     * May communicate with other peers normally.\n+     */\n+    TOX_GROUP_ROLE_USER,\n+\n+    /**\n+     * May observe the group and ignore peers; may not communicate with other peers or with the group.\n+     */\n+    TOX_GROUP_ROLE_OBSERVER,\n+\n+} Tox_Group_Role;\n+\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat instance management\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+typedef enum Tox_Err_Group_New {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_NEW_OK,\n+\n+    /**\n+     * name exceeds TOX_MAX_NAME_LENGTH or group_name exceeded TOX_GROUP_MAX_GROUP_NAME_LENGTH.\n+     */\n+    TOX_ERR_GROUP_NEW_TOO_LONG,\n+\n+    /**\n+     * name or group_name is NULL or length is zero.\n+     */\n+    TOX_ERR_GROUP_NEW_EMPTY,\n+\n+    /**\n+     * The group instance failed to initialize.\n+     */\n+    TOX_ERR_GROUP_NEW_INIT,\n+\n+    /**\n+     * The group state failed to initialize. This usually indicates that something went wrong\n+     * related to cryptographic signing.\n+     */\n+    TOX_ERR_GROUP_NEW_STATE,\n+\n+    /**\n+     * The group failed to announce to the DHT. This indicates a network related error.\n+     */\n+    TOX_ERR_GROUP_NEW_ANNOUNCE,\n+\n+} Tox_Err_Group_New;\n+\n+\n+/**\n+ * Creates a new group chat.\n+ *\n+ * This function creates a new group chat object and adds it to the chats array.\n+ *\n+ * The caller of this function has Founder role privileges.\n+ *\n+ * The client should initiate its peer list with self info after calling this function, as\n+ * the peer_join callback will not be triggered.\n+ *\n+ * @param privacy_state The privacy state of the group. If this is set to TOX_GROUP_PRIVACY_STATE_PUBLIC,\n+ *   the group will attempt to announce itself to the DHT and anyone with the Chat ID may join.\n+ *   Otherwise a friend invite will be required to join the group.\n+ * @param group_name The name of the group. The name must be non-NULL.\n+ * @param group_name_length The length of the group name. This must be greater than zero and no larger than\n+ *   TOX_GROUP_MAX_GROUP_NAME_LENGTH.\n+ * @param name The name of the peer creating the group.\n+ * @param name_length The length of the peer's name. This must be greater than zero and no larger\n+ *   than TOX_MAX_NAME_LENGTH.\n+ *\n+ * @return group_number on success, UINT32_MAX on failure.\n+ */\n+uint32_t tox_group_new(Tox *tox, Tox_Group_Privacy_State privacy_state, const uint8_t *group_name,\n+                       size_t group_name_length, const uint8_t *name, size_t name_length, Tox_Err_Group_New *error);\n+\n+typedef enum Tox_Err_Group_Join {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_JOIN_OK,\n+\n+    /**\n+     * The group instance failed to initialize.\n+     */\n+    TOX_ERR_GROUP_JOIN_INIT,\n+\n+    /**\n+     * The chat_id pointer is set to NULL or a group with chat_id already exists. This usually\n+     * happens if the client attempts to create multiple sessions for the same group.\n+     */\n+    TOX_ERR_GROUP_JOIN_BAD_CHAT_ID,\n+\n+    /**\n+     * name is NULL or name_length is zero.\n+     */\n+    TOX_ERR_GROUP_JOIN_EMPTY,\n+\n+    /**\n+     * name exceeds TOX_MAX_NAME_LENGTH.\n+     */\n+    TOX_ERR_GROUP_JOIN_TOO_LONG,\n+\n+    /**\n+     * Failed to set password. This usually occurs if the password exceeds TOX_GROUP_MAX_PASSWORD_SIZE.\n+     */\n+    TOX_ERR_GROUP_JOIN_PASSWORD,\n+\n+    /**\n+     * There was a core error when initiating the group.\n+     */\n+    TOX_ERR_GROUP_JOIN_CORE,\n+\n+} Tox_Err_Group_Join;\n+\n+\n+/**\n+ * Joins a group chat with specified Chat ID.\n+ *\n+ * This function creates a new group chat object, adds it to the chats array, and sends\n+ * a DHT announcement to find peers in the group associated with chat_id. Once a peer has been\n+ * found a join attempt will be initiated.\n+ *\n+ * @param chat_id The Chat ID of the group you wish to join. This must be TOX_GROUP_CHAT_ID_SIZE bytes.\n+ * @param password The password required to join the group. Set to NULL if no password is required.\n+ * @param password_length The length of the password. If length is equal to zero,\n+ *   the password parameter is ignored. length must be no larger than TOX_GROUP_MAX_PASSWORD_SIZE.\n+ * @param name The name of the peer joining the group.\n+ * @param name_length The length of the peer's name. This must be greater than zero and no larger\n+ *   than TOX_MAX_NAME_LENGTH.\n+ *\n+ * @return group_number on success, UINT32_MAX on failure.\n+ */\n+uint32_t tox_group_join(Tox *tox, const uint8_t *chat_id, const uint8_t *name, size_t name_length,\n+                        const uint8_t *password, size_t password_length, Tox_Err_Group_Join *error);\n+\n+typedef enum Tox_Err_Group_Is_Connected {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_IS_CONNECTED_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_IS_CONNECTED_GROUP_NOT_FOUND,\n+\n+} Tox_Err_Group_Is_Connected;\n+\n+\n+/**\n+ * Returns true if the group chat is currently connected or attempting to connect to other peers\n+ * in the group.\n+ *\n+ * @param group_number The group number of the designated group.\n+ */\n+bool tox_group_is_connected(const Tox *tox, uint32_t group_number, Tox_Err_Group_Is_Connected *error);\n+\n+typedef enum Tox_Err_Group_Disconnect {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_DISCONNECT_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_DISCONNECT_GROUP_NOT_FOUND,\n+\n+    /**\n+     * The group is already disconnected.\n+     */\n+    TOX_ERR_GROUP_DISCONNECT_ALREADY_DISCONNECTED,\n+} Tox_Err_Group_Disconnect;\n+\n+\n+/**\n+ * Disconnects from a group chat while retaining the group state and credentials.\n+ *\n+ * Returns true if we successfully disconnect from the group.\n+ *\n+ * @param group_number The group number of the designated group.\n+ */\n+bool tox_group_disconnect(const Tox *tox, uint32_t group_number, Tox_Err_Group_Disconnect *error);\n+\n+typedef enum Tox_Err_Group_Reconnect {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_RECONNECT_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_RECONNECT_GROUP_NOT_FOUND,\n+\n+    /**\n+     * There was a core error when initiating the group.\n+     */\n+    TOX_ERR_GROUP_RECONNECT_CORE,\n+\n+} Tox_Err_Group_Reconnect;\n+\n+\n+/**\n+ * Reconnects to a group.\n+ *\n+ * This function disconnects from all peers in the group, then attempts to reconnect with the group.\n+ * The caller's state is not changed (i.e. name, status, role, chat public key etc.).\n+ *\n+ * @param group_number The group number of the group we wish to reconnect to.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_reconnect(Tox *tox, uint32_t group_number, Tox_Err_Group_Reconnect *error);\n+\n+typedef enum Tox_Err_Group_Leave {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_LEAVE_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_LEAVE_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Message length exceeded TOX_GROUP_MAX_PART_LENGTH.\n+     */\n+    TOX_ERR_GROUP_LEAVE_TOO_LONG,\n+\n+    /**\n+     * The parting packet failed to send.\n+     */\n+    TOX_ERR_GROUP_LEAVE_FAIL_SEND,\n+} Tox_Err_Group_Leave;\n+\n+\n+/**\n+ * Leaves a group.\n+ *\n+ * This function sends a parting packet containing a custom (non-obligatory) message to all\n+ * peers in a group, and deletes the group from the chat array. All group state information is permanently\n+ * lost, including keys and role credentials.\n+ *\n+ * @param group_number The group number of the group we wish to leave.\n+ * @param part_message The parting message to be sent to all the peers. Set to NULL if we do not wish to\n+ *   send a parting message.\n+ * @param length The length of the parting message. Set to 0 if we do not wish to send a parting message.\n+ *\n+ * @return true if the group chat instance is successfully deleted.\n+ */\n+bool tox_group_leave(Tox *tox, uint32_t group_number, const uint8_t *part_message, size_t length,\n+                     Tox_Err_Group_Leave *error);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group user-visible client information (nickname/status/role/public key)\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/**\n+ * General error codes for self state get and size functions.\n+ */\n+typedef enum Tox_Err_Group_Self_Query {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SELF_QUERY_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SELF_QUERY_GROUP_NOT_FOUND,\n+\n+} Tox_Err_Group_Self_Query;\n+\n+\n+/**\n+ * Error codes for self name setting.\n+ */\n+typedef enum Tox_Err_Group_Self_Name_Set {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Name length exceeded TOX_MAX_NAME_LENGTH.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_TOO_LONG,\n+\n+    /**\n+     * The length given to the set function is zero or name is a NULL pointer.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_INVALID,\n+\n+    /**\n+     * The name is already taken by another peer in the group.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_TAKEN,\n+\n+    /**\n+     * The packet failed to send.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_FAIL_SEND,\n+\n+} Tox_Err_Group_Self_Name_Set;\n+\n+\n+/**\n+ * Set the client's nickname for the group instance designated by the given group number.\n+ *\n+ * Nickname length cannot exceed TOX_MAX_NAME_LENGTH. If length is equal to zero or name is a NULL\n+ * pointer, the function call will fail.\n+ *\n+ * @param name A byte array containing the new nickname.\n+ * @param length The size of the name byte array.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_self_set_name(const Tox *tox, uint32_t group_number, const uint8_t *name, size_t length,\n+                             Tox_Err_Group_Self_Name_Set *error);\n+\n+/**\n+ * Return the length of the client's current nickname for the group instance designated\n+ * by group_number as passed to tox_group_self_set_name.\n+ *\n+ * If no nickname was set before calling this function, the name is empty,\n+ * and this function returns 0.\n+ *\n+ * @see threading for concurrency implications.\n+ */\n+size_t tox_group_self_get_name_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * Write the nickname set by tox_group_self_set_name to a byte array.\n+ *\n+ * If no nickname was set before calling this function, the name is empty,\n+ * and this function has no effect.\n+ *\n+ * Call tox_group_self_get_name_size to find out how much memory to allocate for the result.\n+ *\n+ * @param name A valid memory location large enough to hold the nickname.\n+ *   If this parameter is NULL, the function has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_self_get_name(const Tox *tox, uint32_t group_number, uint8_t *name, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * Error codes for self status setting.\n+ */\n+typedef enum Tox_Err_Group_Self_Status_Set {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SELF_STATUS_SET_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SELF_STATUS_SET_GROUP_NOT_FOUND,\n+\n+    /**\n+     * The packet failed to send.\n+     */\n+    TOX_ERR_GROUP_SELF_STATUS_SET_FAIL_SEND,\n+\n+} Tox_Err_Group_Self_Status_Set;\n+\n+\n+/**\n+ * Set the client's status for the group instance. Status must be a Tox_User_Status.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_self_set_status(const Tox *tox, uint32_t group_number, Tox_User_Status status,\n+                               Tox_Err_Group_Self_Status_Set *error);\n+\n+/**\n+ * returns the client's status for the group instance on success.\n+ * return value is unspecified on failure.\n+ */\n+Tox_User_Status tox_group_self_get_status(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * returns the client's role for the group instance on success.\n+ * return value is unspecified on failure.\n+ */\n+Tox_Group_Role tox_group_self_get_role(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * returns the client's peer id for the group instance on success.\n+ * return value is unspecified on failure.\n+ */\n+uint32_t tox_group_self_get_peer_id(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * Write the client's group public key designated by the given group number to a byte array.\n+ *\n+ * This key will be permanently tied to the client's identity for this particular group until\n+ * the client explicitly leaves the group. This key is the only way for other peers to reliably\n+ * identify the client across client restarts.\n+ *\n+ * `public_key` should have room for at least TOX_GROUP_PEER_PUBLIC_KEY_SIZE bytes.\n+ *\n+ * @param public_key A valid memory region large enough to store the public key.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_self_get_public_key(const Tox *tox, uint32_t group_number, uint8_t *public_key,\n+                                   Tox_Err_Group_Self_Query *error);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Peer-specific group state queries.\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/**\n+ * Error codes for peer info queries.\n+ */\n+typedef enum Tox_Err_Group_Peer_Query {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_PEER_QUERY_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND,\n+\n+    /**\n+     * The ID passed did not designate a valid peer.\n+     */\n+    TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND,\n+\n+} Tox_Err_Group_Peer_Query;\n+\n+\n+/**\n+ * Return the length of the peer's name. If the group number or ID is invalid, the\n+ * return value is unspecified.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose name length we want to retrieve.\n+ *\n+ * The return value is equal to the `length` argument received by the last\n+ * `group_peer_name` callback.\n+ */\n+size_t tox_group_peer_get_name_size(const Tox *tox, uint32_t group_number, uint32_t peer_id,\n+                                    Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Write the name of the peer designated by the given ID to a byte\n+ * array.\n+ *\n+ * Call tox_group_peer_get_name_size to determine the allocation size for the `name` parameter.\n+ *\n+ * The data written to `name` is equal to the data received by the last\n+ * `group_peer_name` callback.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose name we wish to retrieve.\n+ * @param name A valid memory region large enough to store the friend's name.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_peer_get_name(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *name,\n+                             Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Return the peer's user status (away/busy/...). If the ID or group number is\n+ * invalid, the return value is unspecified.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose status we wish to query.\n+ *\n+ * The status returned is equal to the last status received through the\n+ * `group_peer_status` callback.\n+ */\n+Tox_User_Status tox_group_peer_get_status(const Tox *tox, uint32_t group_number, uint32_t peer_id,\n+        Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Return the peer's role (user/moderator/founder...). If the ID or group number is\n+ * invalid, the return value is unspecified.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose role we wish to query.\n+ *\n+ * The role returned is equal to the last role received through the\n+ * `group_moderation` callback.\n+ */\n+Tox_Group_Role tox_group_peer_get_role(const Tox *tox, uint32_t group_number, uint32_t peer_id,\n+                                       Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Return the type of connection we have established with a peer.\n+ *\n+ * This function will return an error if called on ourselves.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose connection status we wish to query.\n+ */\n+Tox_Connection tox_group_peer_get_connection_status(const Tox *tox, uint32_t group_number, uint32_t peer_id,\n+        Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Write the group public key with the designated peer_id for the designated group number to public_key.\n+ *\n+ * This key will be permanently tied to a particular peer until they explicitly leave the group or\n+ * get kicked, and is the only way to reliably identify the same peer across client restarts.\n+ *\n+ * `public_key` should have room for at least TOX_GROUP_PEER_PUBLIC_KEY_SIZE bytes. If `public_key` is null\n+ * this function has no effect.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose public key we wish to retrieve.\n+ * @param public_key A valid memory region large enough to store the public key.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_peer_get_public_key(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *public_key,\n+                                   Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * @param group_number The group number of the group the name change is intended for.\n+ * @param peer_id The ID of the peer who has changed their name.\n+ * @param name The name data.\n+ * @param length The length of the name.\n+ */\n+typedef void tox_group_peer_name_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, const uint8_t *name,\n+                                    size_t length, void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_peer_name` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when a peer changes their nickname.\n+ */\n+void tox_callback_group_peer_name(Tox *tox, tox_group_peer_name_cb *callback);\n+\n+/**\n+ * @param group_number The group number of the group the status change is intended for.\n+ * @param peer_id The ID of the peer who has changed their status.\n+ * @param status The new status of the peer.\n+ */\n+typedef void tox_group_peer_status_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_User_Status status,\n+                                      void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_peer_status` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when a peer changes their status.\n+ */\n+void tox_callback_group_peer_status(Tox *tox, tox_group_peer_status_cb *callback);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat state queries and events.\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/**\n+ * General error codes for group state get and size functions.\n+ */\n+typedef enum Tox_Err_Group_State_Queries {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_STATE_QUERIES_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND,\n+\n+} Tox_Err_Group_State_Queries;\n+\n+\n+/**\n+ * Error codes for group topic setting.\n+ */\n+typedef enum Tox_Err_Group_Topic_Set {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Topic length exceeded TOX_GROUP_MAX_TOPIC_LENGTH.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_TOO_LONG,\n+\n+    /**\n+     * The caller does not have the required permissions to set the topic.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_PERMISSIONS,\n+\n+    /**\n+     * The packet could not be created. This error is usually related to cryptographic signing.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_FAIL_CREATE,\n+\n+    /**\n+     * The packet failed to send.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_FAIL_SEND,\n+\n+    /**\n+     * The group is disconnected.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_DISCONNECTED,\n+\n+} Tox_Err_Group_Topic_Set;\n+\n+\n+/**\n+ * Set the group topic and broadcast it to the rest of the group.\n+ *\n+ * topic length cannot be longer than TOX_GROUP_MAX_TOPIC_LENGTH. If length is equal to zero or\n+ * topic is set to NULL, the topic will be unset.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_set_topic(const Tox *tox, uint32_t group_number, const uint8_t *topic, size_t length,\n+                         Tox_Err_Group_Topic_Set *error);\n+\n+/**\n+ * Return the length of the group topic. If the group number is invalid, the\n+ * return value is unspecified.\n+ *\n+ * The return value is equal to the `length` argument received by the last\n+ * `group_topic` callback.\n+ */\n+size_t tox_group_get_topic_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Write the topic designated by the given group number to a byte array.\n+ *\n+ * Call tox_group_get_topic_size to determine the allocation size for the `topic` parameter.\n+ *\n+ * The data written to `topic` is equal to the data received by the last\n+ * `group_topic` callback.\n+ *\n+ * @param topic A valid memory region large enough to store the topic.\n+ *   If this parameter is NULL, this function has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_get_topic(const Tox *tox, uint32_t group_number, uint8_t *topic, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group the topic change is intended for.\n+ * @param peer_id The ID of the peer who changed the topic. If the peer who set the topic\n+ *   is not present in our peer list this value will be set to 0.\n+ * @param topic The topic data.\n+ * @param length The topic length.\n+ */\n+typedef void tox_group_topic_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, const uint8_t *topic, size_t length,\n+                                void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_topic` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when a peer changes the group topic.\n+ */\n+void tox_callback_group_topic(Tox *tox, tox_group_topic_cb *callback);\n+\n+/**\n+ * Return the length of the group name. If the group number is invalid, the\n+ * return value is unspecified.\n+ */\n+size_t tox_group_get_name_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Write the name of the group designated by the given group number to a byte array.\n+ *\n+ * Call tox_group_get_name_size to determine the allocation size for the `name` parameter.\n+ *\n+ * @param name A valid memory region large enough to store the group name.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_get_name(const Tox *tox, uint32_t group_number, uint8_t *name, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Write the Chat ID designated by the given group number to a byte array.\n+ *\n+ * `chat_id` should have room for at least TOX_GROUP_CHAT_ID_SIZE bytes.\n+ *\n+ * @param chat_id A valid memory region large enough to store the Chat ID.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_get_chat_id(const Tox *tox, uint32_t group_number, uint8_t *chat_id, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Return the number of groups in the Tox chats array.\n+ */\n+uint32_t tox_group_get_number_groups(const Tox *tox);\n+\n+/**\n+ * Return the privacy state of the group designated by the given group number. If group number\n+ * is invalid, the return value is unspecified.\n+ *\n+ * The value returned is equal to the data received by the last\n+ * `group_privacy_state` callback.\n+ *\n+ * @see the `Group chat founder controls` section for the respective set function.\n+ */\n+Tox_Group_Privacy_State tox_group_get_privacy_state(const Tox *tox, uint32_t group_number,\n+        Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group the privacy state is intended for.\n+ * @param privacy_state The new privacy state.\n+ */\n+typedef void tox_group_privacy_state_cb(Tox *tox, uint32_t group_number, Tox_Group_Privacy_State privacy_state,\n+                                        void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_privacy_state` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the privacy state.\n+ */\n+void tox_callback_group_privacy_state(Tox *tox, tox_group_privacy_state_cb *callback);\n+\n+/**\n+ * Return the voice state of the group designated by the given group number. If group number\n+ * is invalid, the return value is unspecified.\n+ *\n+ * The value returned is equal to the data received by the last `group_voice_state` callback.\n+ *\n+ * @see the `Group chat founder controls` section for the respective set function.\n+ */\n+Tox_Group_Voice_State tox_group_get_voice_state(const Tox *tox, uint32_t group_number,\n+        Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group the voice state change is intended for.\n+ * @param voice_state The new voice state.\n+ */\n+typedef void tox_group_voice_state_cb(Tox *tox, uint32_t group_number, Tox_Group_Voice_State voice_state,\n+                                      void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_privacy_state` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the voice state.\n+ */\n+void tox_callback_group_voice_state(Tox *tox, tox_group_voice_state_cb *callback);\n+\n+/**\n+ * Return the topic lock status of the group designated by the given group number. If group number\n+ * is invalid, the return value is unspecified.\n+ *\n+ * The value returned is equal to the data received by the last\n+ * `group_topic_lock` callback.\n+ *\n+ * @see the `Group chat founder contols` section for the respective set function.\n+ */\n+Tox_Group_Topic_Lock tox_group_get_topic_lock(const Tox *tox, uint32_t group_number,\n+        Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group for which the topic lock has changed.\n+ * @param topic_lock The new topic lock state.\n+ */\n+typedef void tox_group_topic_lock_cb(Tox *tox, uint32_t group_number, Tox_Group_Topic_Lock topic_lock, void *user_data);\n+\n+\n+\n+/**\n+ * Set the callback for the `group_topic_lock` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the topic lock status.\n+ */\n+void tox_callback_group_topic_lock(Tox *tox, tox_group_topic_lock_cb *callback);\n+\n+/**\n+ * Return the maximum number of peers allowed for the group designated by the given group number.\n+ * If the group number is invalid, the return value is unspecified.\n+ *\n+ * The value returned is equal to the data received by the last\n+ * `group_peer_limit` callback.\n+ *\n+ * @see the `Group chat founder controls` section for the respective set function.\n+ */\n+uint16_t tox_group_get_peer_limit(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group for which the peer limit has changed.\n+ * @param peer_limit The new peer limit for the group.\n+ */\n+typedef void tox_group_peer_limit_cb(Tox *tox, uint32_t group_number, uint32_t peer_limit, void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_peer_limit` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the maximum peer limit.\n+ */\n+void tox_callback_group_peer_limit(Tox *tox, tox_group_peer_limit_cb *callback);\n+\n+/**\n+ * Return the length of the group password. If the group number is invalid, the\n+ * return value is unspecified.\n+ */\n+size_t tox_group_get_password_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Write the password for the group designated by the given group number to a byte array.\n+ *\n+ * Call tox_group_get_password_size to determine the allocation size for the `password` parameter.\n+ *\n+ * The data received is equal to the data received by the last\n+ * `group_password` callback.\n+ *\n+ * @see the `Group chat founder controls` section for the respective set function.\n+ *\n+ * @param password A valid memory region large enough to store the group password.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_get_password(const Tox *tox, uint32_t group_number, uint8_t *password,\n+                            Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group for which the password has changed.\n+ * @param password The new group password.\n+ * @param length The length of the password.\n+ */\n+typedef void tox_group_password_cb(Tox *tox, uint32_t group_number, const uint8_t *password, size_t length,\n+                                   void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_password` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the group password.\n+ */\n+void tox_callback_group_password(Tox *tox, tox_group_password_cb *callback);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat message sending\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+typedef enum Tox_Err_Group_Send_Message {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Message length exceeded TOX_MAX_MESSAGE_LENGTH.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_TOO_LONG,\n+\n+    /**\n+     * The message pointer is null or length is zero.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_EMPTY,\n+\n+    /**\n+     * The message type is invalid.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_BAD_TYPE,\n+\n+    /**\n+     * The caller does not have the required permissions to send group messages.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_PERMISSIONS,\n+\n+    /**\n+     * Packet failed to send.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_FAIL_SEND,\n+\n+    /**\n+     * The group is disconnected.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_DISCONNECTED,\n+\n+} Tox_Err_Group_Send_Message;\n+\n+\n+/**\n+ * Send a text chat message to the group.\n+ *\n+ * This function creates a group message packet and pushes it into the send\n+ * queue.\n+ *\n+ * The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages\n+ * must be split by the client and sent as separate messages. Other clients can\n+ * then reassemble the fragments. Messages may not be empty.\n+ *\n+ * @param group_number The group number of the group the message is intended for.\n+ * @param type Message type (normal, action, ...).\n+ * @param message A non-NULL pointer to the first element of a byte array\n+ *   containing the message text.\n+ * @param length Length of the message to be sent.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_send_message(const Tox *tox, uint32_t group_number, Tox_Message_Type type, const uint8_t *message,\n+                            size_t length, Tox_Err_Group_Send_Message *error);\n+\n+typedef enum Tox_Err_Group_Send_Private_Message {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_GROUP_NOT_FOUND,\n+\n+    /**\n+     * The ID passed did not designate a valid peer.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PEER_NOT_FOUND,\n+\n+    /**\n+     * Message length exceeded TOX_MAX_MESSAGE_LENGTH.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_TOO_LONG,\n+\n+    /**\n+     * The message pointer is null or length is zero.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_EMPTY,\n+\n+    /**\n+     * The caller does not have the required permissions to send group messages.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PERMISSIONS,\n+\n+    /**\n+     * Packet failed to send.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_FAIL_SEND,\n+\n+    /**\n+     * The group is disconnected.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_DISCONNECTED,\n+\n+    /**\n+     * The message type is invalid.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_BAD_TYPE,\n+\n+} Tox_Err_Group_Send_Private_Message;\n+\n+\n+/**\n+ * Send a text chat message to the specified peer in the specified group.\n+ *\n+ * This function creates a group private message packet and pushes it into the send\n+ * queue.\n+ *\n+ * The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages\n+ * must be split by the client and sent as separate messages. Other clients can\n+ * then reassemble the fragments. Messages may not be empty.\n+ *\n+ * @param group_number The group number of the group the message is intended for.\n+ * @param peer_id The ID of the peer the message is intended for.\n+ * @param message A non-NULL pointer to the first element of a byte array\n+ *   containing the message text.\n+ * @param length Length of the message to be sent.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_send_private_message(const Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_Message_Type type,\n+                                    const uint8_t *message, size_t length, Tox_Err_Group_Send_Private_Message *error);\n+\n+typedef enum Tox_Err_Group_Send_Custom_Packet {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Message length exceeded TOX_MAX_MESSAGE_LENGTH.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_TOO_LONG,\n+\n+    /**\n+     * The message pointer is null or length is zero.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_EMPTY,\n+\n+    /**\n+     * The caller does not have the required permissions to send group messages.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_PERMISSIONS,\n+\n+    /**\n+     * The group is disconnected.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_DISCONNECTED,\n+\n+} Tox_Err_Group_Send_Custom_Packet;\n+\n+\n+/**\n+ * Send a custom packet to the group.\n+ *\n+ * If lossless is true the packet will be lossless. Lossless packet behaviour is comparable\n+ * to TCP (reliability, arrive in order) but with packets instead of a stream.\n+ *\n+ * If lossless is false, the packet will be lossy. Lossy packets behave like UDP packets,\n+ * meaning they might never reach the other side or might arrive more than once (if someone\n+ * is messing with the connection) or might arrive in the wrong order.\n+ *\n+ * Unless latency is an issue or message reliability is not important, it is recommended that you use\n+ * lossless custom packets.\n+ *\n+ * @param group_number The group number of the group the message is intended for.\n+ * @param lossless True if the packet should be lossless.\n+ * @param data A byte array containing the packet data.\n+ * @param length The length of the packet data byte array.",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r866285683",
            "id": 866285683,
            "line": 4522,
            "node_id": "PRRC_kwDOA7zIGs4zonhz",
            "original_commit_id": "0d3167a4057da6f818e5ff204bcf51116edf2ece",
            "original_line": 4522,
            "original_position": 1249,
            "original_start_line": null,
            "path": "toxcore/tox.h",
            "position": 1256,
            "pull_request_review_id": 963915709,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/866285683/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-05-05T20:24:07Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/866285683",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2938071?v=4",
                "events_url": "https://api.github.com/users/Green-Sky/events{/privacy}",
                "followers_url": "https://api.github.com/users/Green-Sky/followers",
                "following_url": "https://api.github.com/users/Green-Sky/following{/other_user}",
                "gists_url": "https://api.github.com/users/Green-Sky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Green-Sky",
                "id": 2938071,
                "login": "Green-Sky",
                "node_id": "MDQ6VXNlcjI5MzgwNzE=",
                "organizations_url": "https://api.github.com/users/Green-Sky/orgs",
                "received_events_url": "https://api.github.com/users/Green-Sky/received_events",
                "repos_url": "https://api.github.com/users/Green-Sky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Green-Sky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Green-Sky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Green-Sky",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r867232592"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/867232592"
                }
            },
            "author_association": "MEMBER",
            "body": "That's probably how it's intended, but right now it checks for `MAX_GC_MESSAGE_SIZE`, which is 1 byte shorter.",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-05-06T21:42:24Z",
            "diff_hunk": "@@ -3267,6 +3267,2167 @@ uint16_t tox_self_get_tcp_port(const Tox *tox, Tox_Err_Get_Port *error);\n \n /** @} */\n \n+/*******************************************************************************\n+ *\n+ * :: Group chats\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat numeric constants\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/** @{\n+ * Maximum length of a group topic.\n+ */\n+#define TOX_GROUP_MAX_TOPIC_LENGTH     512\n+\n+uint32_t tox_group_max_topic_length(void);\n+\n+/**\n+ * Maximum length of a peer part message.\n+ */\n+#define TOX_GROUP_MAX_PART_LENGTH      128\n+\n+uint32_t tox_group_max_part_length(void);\n+\n+/**\n+ * Maximum length of a group name.\n+ */\n+#define TOX_GROUP_MAX_GROUP_NAME_LENGTH 48\n+\n+uint32_t tox_group_max_group_name_length(void);\n+\n+/**\n+ * Maximum length of a group password.\n+ */\n+#define TOX_GROUP_MAX_PASSWORD_SIZE    32\n+\n+uint32_t tox_group_max_password_size(void);\n+\n+/**\n+ * Number of bytes in a group Chat ID.\n+ */\n+#define TOX_GROUP_CHAT_ID_SIZE         32\n+\n+uint32_t tox_group_chat_id_size(void);\n+\n+/**\n+ * Size of a peer public key.\n+ */\n+#define TOX_GROUP_PEER_PUBLIC_KEY_SIZE 32\n+\n+uint32_t tox_group_peer_public_key_size(void);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat state enumerators\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/**\n+ * Represents the group privacy state.\n+ */\n+typedef enum Tox_Group_Privacy_State {\n+\n+    /**\n+     * The group is considered to be public. Anyone may join the group using the Chat ID.\n+     *\n+     * If the group is in this state, even if the Chat ID is never explicitly shared\n+     * with someone outside of the group, information including the Chat ID, IP addresses,\n+     * and peer ID's (but not Tox ID's) is visible to anyone with access to a node\n+     * storing a DHT entry for the given group.\n+     */\n+    TOX_GROUP_PRIVACY_STATE_PUBLIC,\n+\n+    /**\n+     * The group is considered to be private. The only way to join the group is by having\n+     * someone in your contact list send you an invite.\n+     *\n+     * If the group is in this state, no group information (mentioned above) is present in the DHT;\n+     * the DHT is not used for any purpose at all. If a public group is set to private,\n+     * all DHT information related to the group will expire shortly.\n+     */\n+    TOX_GROUP_PRIVACY_STATE_PRIVATE,\n+\n+} Tox_Group_Privacy_State;\n+\n+\n+/**\n+ * Represents the state of the group topic lock.\n+ */\n+typedef enum Tox_Group_Topic_Lock {\n+\n+    /**\n+     * The topic lock is enabled. Only peers with the founder and moderator roles may set the topic.\n+     */\n+    TOX_GROUP_TOPIC_LOCK_ENABLED,\n+\n+    /**\n+     * The topic lock is disabled. All peers except those with the observer role may set the topic.\n+     */\n+    TOX_GROUP_TOPIC_LOCK_DISABLED,\n+\n+} Tox_Group_Topic_Lock;\n+\n+/**\n+ * Represents the group voice state, which determines which Group Roles have permission to speak\n+ * in the group chat. The voice state does not have any effect private messages or topic setting.\n+ */\n+typedef enum Tox_Group_Voice_State {\n+    /**\n+     * All group roles above Observer have permission to speak.\n+     */\n+    TOX_GROUP_VOICE_STATE_ALL,\n+\n+    /**\n+     * Moderators and Founders have permission to speak.\n+     */\n+    TOX_GROUP_VOICE_STATE_MODERATOR,\n+\n+    /**\n+     * Only the founder may speak.\n+     */\n+    TOX_GROUP_VOICE_STATE_FOUNDER,\n+} Tox_Group_Voice_State;\n+\n+/**\n+ * Represents group roles.\n+ *\n+ * Roles are hierarchical in that each role has a set of privileges plus all the privileges\n+ * of the roles below it.\n+ */\n+typedef enum Tox_Group_Role {\n+\n+    /**\n+     * May kick all other peers as well as set their role to anything (except founder).\n+     * Founders may also set the group password, toggle the privacy state, and set the peer limit.\n+     */\n+    TOX_GROUP_ROLE_FOUNDER,\n+\n+    /**\n+     * May kick and set the user and observer roles for peers below this role.\n+     * May also set the group topic.\n+     */\n+    TOX_GROUP_ROLE_MODERATOR,\n+\n+    /**\n+     * May communicate with other peers normally.\n+     */\n+    TOX_GROUP_ROLE_USER,\n+\n+    /**\n+     * May observe the group and ignore peers; may not communicate with other peers or with the group.\n+     */\n+    TOX_GROUP_ROLE_OBSERVER,\n+\n+} Tox_Group_Role;\n+\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat instance management\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+typedef enum Tox_Err_Group_New {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_NEW_OK,\n+\n+    /**\n+     * name exceeds TOX_MAX_NAME_LENGTH or group_name exceeded TOX_GROUP_MAX_GROUP_NAME_LENGTH.\n+     */\n+    TOX_ERR_GROUP_NEW_TOO_LONG,\n+\n+    /**\n+     * name or group_name is NULL or length is zero.\n+     */\n+    TOX_ERR_GROUP_NEW_EMPTY,\n+\n+    /**\n+     * The group instance failed to initialize.\n+     */\n+    TOX_ERR_GROUP_NEW_INIT,\n+\n+    /**\n+     * The group state failed to initialize. This usually indicates that something went wrong\n+     * related to cryptographic signing.\n+     */\n+    TOX_ERR_GROUP_NEW_STATE,\n+\n+    /**\n+     * The group failed to announce to the DHT. This indicates a network related error.\n+     */\n+    TOX_ERR_GROUP_NEW_ANNOUNCE,\n+\n+} Tox_Err_Group_New;\n+\n+\n+/**\n+ * Creates a new group chat.\n+ *\n+ * This function creates a new group chat object and adds it to the chats array.\n+ *\n+ * The caller of this function has Founder role privileges.\n+ *\n+ * The client should initiate its peer list with self info after calling this function, as\n+ * the peer_join callback will not be triggered.\n+ *\n+ * @param privacy_state The privacy state of the group. If this is set to TOX_GROUP_PRIVACY_STATE_PUBLIC,\n+ *   the group will attempt to announce itself to the DHT and anyone with the Chat ID may join.\n+ *   Otherwise a friend invite will be required to join the group.\n+ * @param group_name The name of the group. The name must be non-NULL.\n+ * @param group_name_length The length of the group name. This must be greater than zero and no larger than\n+ *   TOX_GROUP_MAX_GROUP_NAME_LENGTH.\n+ * @param name The name of the peer creating the group.\n+ * @param name_length The length of the peer's name. This must be greater than zero and no larger\n+ *   than TOX_MAX_NAME_LENGTH.\n+ *\n+ * @return group_number on success, UINT32_MAX on failure.\n+ */\n+uint32_t tox_group_new(Tox *tox, Tox_Group_Privacy_State privacy_state, const uint8_t *group_name,\n+                       size_t group_name_length, const uint8_t *name, size_t name_length, Tox_Err_Group_New *error);\n+\n+typedef enum Tox_Err_Group_Join {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_JOIN_OK,\n+\n+    /**\n+     * The group instance failed to initialize.\n+     */\n+    TOX_ERR_GROUP_JOIN_INIT,\n+\n+    /**\n+     * The chat_id pointer is set to NULL or a group with chat_id already exists. This usually\n+     * happens if the client attempts to create multiple sessions for the same group.\n+     */\n+    TOX_ERR_GROUP_JOIN_BAD_CHAT_ID,\n+\n+    /**\n+     * name is NULL or name_length is zero.\n+     */\n+    TOX_ERR_GROUP_JOIN_EMPTY,\n+\n+    /**\n+     * name exceeds TOX_MAX_NAME_LENGTH.\n+     */\n+    TOX_ERR_GROUP_JOIN_TOO_LONG,\n+\n+    /**\n+     * Failed to set password. This usually occurs if the password exceeds TOX_GROUP_MAX_PASSWORD_SIZE.\n+     */\n+    TOX_ERR_GROUP_JOIN_PASSWORD,\n+\n+    /**\n+     * There was a core error when initiating the group.\n+     */\n+    TOX_ERR_GROUP_JOIN_CORE,\n+\n+} Tox_Err_Group_Join;\n+\n+\n+/**\n+ * Joins a group chat with specified Chat ID.\n+ *\n+ * This function creates a new group chat object, adds it to the chats array, and sends\n+ * a DHT announcement to find peers in the group associated with chat_id. Once a peer has been\n+ * found a join attempt will be initiated.\n+ *\n+ * @param chat_id The Chat ID of the group you wish to join. This must be TOX_GROUP_CHAT_ID_SIZE bytes.\n+ * @param password The password required to join the group. Set to NULL if no password is required.\n+ * @param password_length The length of the password. If length is equal to zero,\n+ *   the password parameter is ignored. length must be no larger than TOX_GROUP_MAX_PASSWORD_SIZE.\n+ * @param name The name of the peer joining the group.\n+ * @param name_length The length of the peer's name. This must be greater than zero and no larger\n+ *   than TOX_MAX_NAME_LENGTH.\n+ *\n+ * @return group_number on success, UINT32_MAX on failure.\n+ */\n+uint32_t tox_group_join(Tox *tox, const uint8_t *chat_id, const uint8_t *name, size_t name_length,\n+                        const uint8_t *password, size_t password_length, Tox_Err_Group_Join *error);\n+\n+typedef enum Tox_Err_Group_Is_Connected {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_IS_CONNECTED_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_IS_CONNECTED_GROUP_NOT_FOUND,\n+\n+} Tox_Err_Group_Is_Connected;\n+\n+\n+/**\n+ * Returns true if the group chat is currently connected or attempting to connect to other peers\n+ * in the group.\n+ *\n+ * @param group_number The group number of the designated group.\n+ */\n+bool tox_group_is_connected(const Tox *tox, uint32_t group_number, Tox_Err_Group_Is_Connected *error);\n+\n+typedef enum Tox_Err_Group_Disconnect {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_DISCONNECT_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_DISCONNECT_GROUP_NOT_FOUND,\n+\n+    /**\n+     * The group is already disconnected.\n+     */\n+    TOX_ERR_GROUP_DISCONNECT_ALREADY_DISCONNECTED,\n+} Tox_Err_Group_Disconnect;\n+\n+\n+/**\n+ * Disconnects from a group chat while retaining the group state and credentials.\n+ *\n+ * Returns true if we successfully disconnect from the group.\n+ *\n+ * @param group_number The group number of the designated group.\n+ */\n+bool tox_group_disconnect(const Tox *tox, uint32_t group_number, Tox_Err_Group_Disconnect *error);\n+\n+typedef enum Tox_Err_Group_Reconnect {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_RECONNECT_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_RECONNECT_GROUP_NOT_FOUND,\n+\n+    /**\n+     * There was a core error when initiating the group.\n+     */\n+    TOX_ERR_GROUP_RECONNECT_CORE,\n+\n+} Tox_Err_Group_Reconnect;\n+\n+\n+/**\n+ * Reconnects to a group.\n+ *\n+ * This function disconnects from all peers in the group, then attempts to reconnect with the group.\n+ * The caller's state is not changed (i.e. name, status, role, chat public key etc.).\n+ *\n+ * @param group_number The group number of the group we wish to reconnect to.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_reconnect(Tox *tox, uint32_t group_number, Tox_Err_Group_Reconnect *error);\n+\n+typedef enum Tox_Err_Group_Leave {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_LEAVE_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_LEAVE_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Message length exceeded TOX_GROUP_MAX_PART_LENGTH.\n+     */\n+    TOX_ERR_GROUP_LEAVE_TOO_LONG,\n+\n+    /**\n+     * The parting packet failed to send.\n+     */\n+    TOX_ERR_GROUP_LEAVE_FAIL_SEND,\n+} Tox_Err_Group_Leave;\n+\n+\n+/**\n+ * Leaves a group.\n+ *\n+ * This function sends a parting packet containing a custom (non-obligatory) message to all\n+ * peers in a group, and deletes the group from the chat array. All group state information is permanently\n+ * lost, including keys and role credentials.\n+ *\n+ * @param group_number The group number of the group we wish to leave.\n+ * @param part_message The parting message to be sent to all the peers. Set to NULL if we do not wish to\n+ *   send a parting message.\n+ * @param length The length of the parting message. Set to 0 if we do not wish to send a parting message.\n+ *\n+ * @return true if the group chat instance is successfully deleted.\n+ */\n+bool tox_group_leave(Tox *tox, uint32_t group_number, const uint8_t *part_message, size_t length,\n+                     Tox_Err_Group_Leave *error);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group user-visible client information (nickname/status/role/public key)\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/**\n+ * General error codes for self state get and size functions.\n+ */\n+typedef enum Tox_Err_Group_Self_Query {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SELF_QUERY_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SELF_QUERY_GROUP_NOT_FOUND,\n+\n+} Tox_Err_Group_Self_Query;\n+\n+\n+/**\n+ * Error codes for self name setting.\n+ */\n+typedef enum Tox_Err_Group_Self_Name_Set {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Name length exceeded TOX_MAX_NAME_LENGTH.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_TOO_LONG,\n+\n+    /**\n+     * The length given to the set function is zero or name is a NULL pointer.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_INVALID,\n+\n+    /**\n+     * The name is already taken by another peer in the group.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_TAKEN,\n+\n+    /**\n+     * The packet failed to send.\n+     */\n+    TOX_ERR_GROUP_SELF_NAME_SET_FAIL_SEND,\n+\n+} Tox_Err_Group_Self_Name_Set;\n+\n+\n+/**\n+ * Set the client's nickname for the group instance designated by the given group number.\n+ *\n+ * Nickname length cannot exceed TOX_MAX_NAME_LENGTH. If length is equal to zero or name is a NULL\n+ * pointer, the function call will fail.\n+ *\n+ * @param name A byte array containing the new nickname.\n+ * @param length The size of the name byte array.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_self_set_name(const Tox *tox, uint32_t group_number, const uint8_t *name, size_t length,\n+                             Tox_Err_Group_Self_Name_Set *error);\n+\n+/**\n+ * Return the length of the client's current nickname for the group instance designated\n+ * by group_number as passed to tox_group_self_set_name.\n+ *\n+ * If no nickname was set before calling this function, the name is empty,\n+ * and this function returns 0.\n+ *\n+ * @see threading for concurrency implications.\n+ */\n+size_t tox_group_self_get_name_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * Write the nickname set by tox_group_self_set_name to a byte array.\n+ *\n+ * If no nickname was set before calling this function, the name is empty,\n+ * and this function has no effect.\n+ *\n+ * Call tox_group_self_get_name_size to find out how much memory to allocate for the result.\n+ *\n+ * @param name A valid memory location large enough to hold the nickname.\n+ *   If this parameter is NULL, the function has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_self_get_name(const Tox *tox, uint32_t group_number, uint8_t *name, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * Error codes for self status setting.\n+ */\n+typedef enum Tox_Err_Group_Self_Status_Set {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SELF_STATUS_SET_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SELF_STATUS_SET_GROUP_NOT_FOUND,\n+\n+    /**\n+     * The packet failed to send.\n+     */\n+    TOX_ERR_GROUP_SELF_STATUS_SET_FAIL_SEND,\n+\n+} Tox_Err_Group_Self_Status_Set;\n+\n+\n+/**\n+ * Set the client's status for the group instance. Status must be a Tox_User_Status.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_self_set_status(const Tox *tox, uint32_t group_number, Tox_User_Status status,\n+                               Tox_Err_Group_Self_Status_Set *error);\n+\n+/**\n+ * returns the client's status for the group instance on success.\n+ * return value is unspecified on failure.\n+ */\n+Tox_User_Status tox_group_self_get_status(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * returns the client's role for the group instance on success.\n+ * return value is unspecified on failure.\n+ */\n+Tox_Group_Role tox_group_self_get_role(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * returns the client's peer id for the group instance on success.\n+ * return value is unspecified on failure.\n+ */\n+uint32_t tox_group_self_get_peer_id(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);\n+\n+/**\n+ * Write the client's group public key designated by the given group number to a byte array.\n+ *\n+ * This key will be permanently tied to the client's identity for this particular group until\n+ * the client explicitly leaves the group. This key is the only way for other peers to reliably\n+ * identify the client across client restarts.\n+ *\n+ * `public_key` should have room for at least TOX_GROUP_PEER_PUBLIC_KEY_SIZE bytes.\n+ *\n+ * @param public_key A valid memory region large enough to store the public key.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_self_get_public_key(const Tox *tox, uint32_t group_number, uint8_t *public_key,\n+                                   Tox_Err_Group_Self_Query *error);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Peer-specific group state queries.\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/**\n+ * Error codes for peer info queries.\n+ */\n+typedef enum Tox_Err_Group_Peer_Query {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_PEER_QUERY_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND,\n+\n+    /**\n+     * The ID passed did not designate a valid peer.\n+     */\n+    TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND,\n+\n+} Tox_Err_Group_Peer_Query;\n+\n+\n+/**\n+ * Return the length of the peer's name. If the group number or ID is invalid, the\n+ * return value is unspecified.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose name length we want to retrieve.\n+ *\n+ * The return value is equal to the `length` argument received by the last\n+ * `group_peer_name` callback.\n+ */\n+size_t tox_group_peer_get_name_size(const Tox *tox, uint32_t group_number, uint32_t peer_id,\n+                                    Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Write the name of the peer designated by the given ID to a byte\n+ * array.\n+ *\n+ * Call tox_group_peer_get_name_size to determine the allocation size for the `name` parameter.\n+ *\n+ * The data written to `name` is equal to the data received by the last\n+ * `group_peer_name` callback.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose name we wish to retrieve.\n+ * @param name A valid memory region large enough to store the friend's name.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_peer_get_name(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *name,\n+                             Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Return the peer's user status (away/busy/...). If the ID or group number is\n+ * invalid, the return value is unspecified.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose status we wish to query.\n+ *\n+ * The status returned is equal to the last status received through the\n+ * `group_peer_status` callback.\n+ */\n+Tox_User_Status tox_group_peer_get_status(const Tox *tox, uint32_t group_number, uint32_t peer_id,\n+        Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Return the peer's role (user/moderator/founder...). If the ID or group number is\n+ * invalid, the return value is unspecified.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose role we wish to query.\n+ *\n+ * The role returned is equal to the last role received through the\n+ * `group_moderation` callback.\n+ */\n+Tox_Group_Role tox_group_peer_get_role(const Tox *tox, uint32_t group_number, uint32_t peer_id,\n+                                       Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Return the type of connection we have established with a peer.\n+ *\n+ * This function will return an error if called on ourselves.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose connection status we wish to query.\n+ */\n+Tox_Connection tox_group_peer_get_connection_status(const Tox *tox, uint32_t group_number, uint32_t peer_id,\n+        Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * Write the group public key with the designated peer_id for the designated group number to public_key.\n+ *\n+ * This key will be permanently tied to a particular peer until they explicitly leave the group or\n+ * get kicked, and is the only way to reliably identify the same peer across client restarts.\n+ *\n+ * `public_key` should have room for at least TOX_GROUP_PEER_PUBLIC_KEY_SIZE bytes. If `public_key` is null\n+ * this function has no effect.\n+ *\n+ * @param group_number The group number of the group we wish to query.\n+ * @param peer_id The ID of the peer whose public key we wish to retrieve.\n+ * @param public_key A valid memory region large enough to store the public key.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_peer_get_public_key(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *public_key,\n+                                   Tox_Err_Group_Peer_Query *error);\n+\n+/**\n+ * @param group_number The group number of the group the name change is intended for.\n+ * @param peer_id The ID of the peer who has changed their name.\n+ * @param name The name data.\n+ * @param length The length of the name.\n+ */\n+typedef void tox_group_peer_name_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, const uint8_t *name,\n+                                    size_t length, void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_peer_name` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when a peer changes their nickname.\n+ */\n+void tox_callback_group_peer_name(Tox *tox, tox_group_peer_name_cb *callback);\n+\n+/**\n+ * @param group_number The group number of the group the status change is intended for.\n+ * @param peer_id The ID of the peer who has changed their status.\n+ * @param status The new status of the peer.\n+ */\n+typedef void tox_group_peer_status_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_User_Status status,\n+                                      void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_peer_status` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when a peer changes their status.\n+ */\n+void tox_callback_group_peer_status(Tox *tox, tox_group_peer_status_cb *callback);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat state queries and events.\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+/**\n+ * General error codes for group state get and size functions.\n+ */\n+typedef enum Tox_Err_Group_State_Queries {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_STATE_QUERIES_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND,\n+\n+} Tox_Err_Group_State_Queries;\n+\n+\n+/**\n+ * Error codes for group topic setting.\n+ */\n+typedef enum Tox_Err_Group_Topic_Set {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Topic length exceeded TOX_GROUP_MAX_TOPIC_LENGTH.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_TOO_LONG,\n+\n+    /**\n+     * The caller does not have the required permissions to set the topic.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_PERMISSIONS,\n+\n+    /**\n+     * The packet could not be created. This error is usually related to cryptographic signing.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_FAIL_CREATE,\n+\n+    /**\n+     * The packet failed to send.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_FAIL_SEND,\n+\n+    /**\n+     * The group is disconnected.\n+     */\n+    TOX_ERR_GROUP_TOPIC_SET_DISCONNECTED,\n+\n+} Tox_Err_Group_Topic_Set;\n+\n+\n+/**\n+ * Set the group topic and broadcast it to the rest of the group.\n+ *\n+ * topic length cannot be longer than TOX_GROUP_MAX_TOPIC_LENGTH. If length is equal to zero or\n+ * topic is set to NULL, the topic will be unset.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_set_topic(const Tox *tox, uint32_t group_number, const uint8_t *topic, size_t length,\n+                         Tox_Err_Group_Topic_Set *error);\n+\n+/**\n+ * Return the length of the group topic. If the group number is invalid, the\n+ * return value is unspecified.\n+ *\n+ * The return value is equal to the `length` argument received by the last\n+ * `group_topic` callback.\n+ */\n+size_t tox_group_get_topic_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Write the topic designated by the given group number to a byte array.\n+ *\n+ * Call tox_group_get_topic_size to determine the allocation size for the `topic` parameter.\n+ *\n+ * The data written to `topic` is equal to the data received by the last\n+ * `group_topic` callback.\n+ *\n+ * @param topic A valid memory region large enough to store the topic.\n+ *   If this parameter is NULL, this function has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_get_topic(const Tox *tox, uint32_t group_number, uint8_t *topic, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group the topic change is intended for.\n+ * @param peer_id The ID of the peer who changed the topic. If the peer who set the topic\n+ *   is not present in our peer list this value will be set to 0.\n+ * @param topic The topic data.\n+ * @param length The topic length.\n+ */\n+typedef void tox_group_topic_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, const uint8_t *topic, size_t length,\n+                                void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_topic` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when a peer changes the group topic.\n+ */\n+void tox_callback_group_topic(Tox *tox, tox_group_topic_cb *callback);\n+\n+/**\n+ * Return the length of the group name. If the group number is invalid, the\n+ * return value is unspecified.\n+ */\n+size_t tox_group_get_name_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Write the name of the group designated by the given group number to a byte array.\n+ *\n+ * Call tox_group_get_name_size to determine the allocation size for the `name` parameter.\n+ *\n+ * @param name A valid memory region large enough to store the group name.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_get_name(const Tox *tox, uint32_t group_number, uint8_t *name, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Write the Chat ID designated by the given group number to a byte array.\n+ *\n+ * `chat_id` should have room for at least TOX_GROUP_CHAT_ID_SIZE bytes.\n+ *\n+ * @param chat_id A valid memory region large enough to store the Chat ID.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_get_chat_id(const Tox *tox, uint32_t group_number, uint8_t *chat_id, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Return the number of groups in the Tox chats array.\n+ */\n+uint32_t tox_group_get_number_groups(const Tox *tox);\n+\n+/**\n+ * Return the privacy state of the group designated by the given group number. If group number\n+ * is invalid, the return value is unspecified.\n+ *\n+ * The value returned is equal to the data received by the last\n+ * `group_privacy_state` callback.\n+ *\n+ * @see the `Group chat founder controls` section for the respective set function.\n+ */\n+Tox_Group_Privacy_State tox_group_get_privacy_state(const Tox *tox, uint32_t group_number,\n+        Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group the privacy state is intended for.\n+ * @param privacy_state The new privacy state.\n+ */\n+typedef void tox_group_privacy_state_cb(Tox *tox, uint32_t group_number, Tox_Group_Privacy_State privacy_state,\n+                                        void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_privacy_state` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the privacy state.\n+ */\n+void tox_callback_group_privacy_state(Tox *tox, tox_group_privacy_state_cb *callback);\n+\n+/**\n+ * Return the voice state of the group designated by the given group number. If group number\n+ * is invalid, the return value is unspecified.\n+ *\n+ * The value returned is equal to the data received by the last `group_voice_state` callback.\n+ *\n+ * @see the `Group chat founder controls` section for the respective set function.\n+ */\n+Tox_Group_Voice_State tox_group_get_voice_state(const Tox *tox, uint32_t group_number,\n+        Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group the voice state change is intended for.\n+ * @param voice_state The new voice state.\n+ */\n+typedef void tox_group_voice_state_cb(Tox *tox, uint32_t group_number, Tox_Group_Voice_State voice_state,\n+                                      void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_privacy_state` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the voice state.\n+ */\n+void tox_callback_group_voice_state(Tox *tox, tox_group_voice_state_cb *callback);\n+\n+/**\n+ * Return the topic lock status of the group designated by the given group number. If group number\n+ * is invalid, the return value is unspecified.\n+ *\n+ * The value returned is equal to the data received by the last\n+ * `group_topic_lock` callback.\n+ *\n+ * @see the `Group chat founder contols` section for the respective set function.\n+ */\n+Tox_Group_Topic_Lock tox_group_get_topic_lock(const Tox *tox, uint32_t group_number,\n+        Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group for which the topic lock has changed.\n+ * @param topic_lock The new topic lock state.\n+ */\n+typedef void tox_group_topic_lock_cb(Tox *tox, uint32_t group_number, Tox_Group_Topic_Lock topic_lock, void *user_data);\n+\n+\n+\n+/**\n+ * Set the callback for the `group_topic_lock` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the topic lock status.\n+ */\n+void tox_callback_group_topic_lock(Tox *tox, tox_group_topic_lock_cb *callback);\n+\n+/**\n+ * Return the maximum number of peers allowed for the group designated by the given group number.\n+ * If the group number is invalid, the return value is unspecified.\n+ *\n+ * The value returned is equal to the data received by the last\n+ * `group_peer_limit` callback.\n+ *\n+ * @see the `Group chat founder controls` section for the respective set function.\n+ */\n+uint16_t tox_group_get_peer_limit(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group for which the peer limit has changed.\n+ * @param peer_limit The new peer limit for the group.\n+ */\n+typedef void tox_group_peer_limit_cb(Tox *tox, uint32_t group_number, uint32_t peer_limit, void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_peer_limit` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the maximum peer limit.\n+ */\n+void tox_callback_group_peer_limit(Tox *tox, tox_group_peer_limit_cb *callback);\n+\n+/**\n+ * Return the length of the group password. If the group number is invalid, the\n+ * return value is unspecified.\n+ */\n+size_t tox_group_get_password_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * Write the password for the group designated by the given group number to a byte array.\n+ *\n+ * Call tox_group_get_password_size to determine the allocation size for the `password` parameter.\n+ *\n+ * The data received is equal to the data received by the last\n+ * `group_password` callback.\n+ *\n+ * @see the `Group chat founder controls` section for the respective set function.\n+ *\n+ * @param password A valid memory region large enough to store the group password.\n+ *   If this parameter is NULL, this function call has no effect.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_get_password(const Tox *tox, uint32_t group_number, uint8_t *password,\n+                            Tox_Err_Group_State_Queries *error);\n+\n+/**\n+ * @param group_number The group number of the group for which the password has changed.\n+ * @param password The new group password.\n+ * @param length The length of the password.\n+ */\n+typedef void tox_group_password_cb(Tox *tox, uint32_t group_number, const uint8_t *password, size_t length,\n+                                   void *user_data);\n+\n+\n+/**\n+ * Set the callback for the `group_password` event. Pass NULL to unset.\n+ *\n+ * This event is triggered when the group founder changes the group password.\n+ */\n+void tox_callback_group_password(Tox *tox, tox_group_password_cb *callback);\n+\n+\n+/*******************************************************************************\n+ *\n+ * :: Group chat message sending\n+ *\n+ ******************************************************************************/\n+\n+\n+\n+typedef enum Tox_Err_Group_Send_Message {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Message length exceeded TOX_MAX_MESSAGE_LENGTH.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_TOO_LONG,\n+\n+    /**\n+     * The message pointer is null or length is zero.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_EMPTY,\n+\n+    /**\n+     * The message type is invalid.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_BAD_TYPE,\n+\n+    /**\n+     * The caller does not have the required permissions to send group messages.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_PERMISSIONS,\n+\n+    /**\n+     * Packet failed to send.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_FAIL_SEND,\n+\n+    /**\n+     * The group is disconnected.\n+     */\n+    TOX_ERR_GROUP_SEND_MESSAGE_DISCONNECTED,\n+\n+} Tox_Err_Group_Send_Message;\n+\n+\n+/**\n+ * Send a text chat message to the group.\n+ *\n+ * This function creates a group message packet and pushes it into the send\n+ * queue.\n+ *\n+ * The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages\n+ * must be split by the client and sent as separate messages. Other clients can\n+ * then reassemble the fragments. Messages may not be empty.\n+ *\n+ * @param group_number The group number of the group the message is intended for.\n+ * @param type Message type (normal, action, ...).\n+ * @param message A non-NULL pointer to the first element of a byte array\n+ *   containing the message text.\n+ * @param length Length of the message to be sent.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_send_message(const Tox *tox, uint32_t group_number, Tox_Message_Type type, const uint8_t *message,\n+                            size_t length, Tox_Err_Group_Send_Message *error);\n+\n+typedef enum Tox_Err_Group_Send_Private_Message {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_GROUP_NOT_FOUND,\n+\n+    /**\n+     * The peer ID passed did not designate a valid peer.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PEER_NOT_FOUND,\n+\n+    /**\n+     * Message length exceeded TOX_MAX_MESSAGE_LENGTH.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_TOO_LONG,\n+\n+    /**\n+     * The message pointer is null or length is zero.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_EMPTY,\n+\n+    /**\n+     * The caller does not have the required permissions to send group messages.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PERMISSIONS,\n+\n+    /**\n+     * Packet failed to send.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_FAIL_SEND,\n+\n+    /**\n+     * The group is disconnected.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_DISCONNECTED,\n+\n+    /**\n+     * The message type is invalid.\n+     */\n+    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_BAD_TYPE,\n+\n+} Tox_Err_Group_Send_Private_Message;\n+\n+\n+/**\n+ * Send a text chat message to the specified peer in the specified group.\n+ *\n+ * This function creates a group private message packet and pushes it into the send\n+ * queue.\n+ *\n+ * The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages\n+ * must be split by the client and sent as separate messages. Other clients can\n+ * then reassemble the fragments. Messages may not be empty.\n+ *\n+ * @param group_number The group number of the group the message is intended for.\n+ * @param peer_id The ID of the peer the message is intended for.\n+ * @param message A non-NULL pointer to the first element of a byte array\n+ *   containing the message text.\n+ * @param length Length of the message to be sent.\n+ *\n+ * @return true on success.\n+ */\n+bool tox_group_send_private_message(const Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_Message_Type type,\n+                                    const uint8_t *message, size_t length, Tox_Err_Group_Send_Private_Message *error);\n+\n+typedef enum Tox_Err_Group_Send_Custom_Packet {\n+\n+    /**\n+     * The function returned successfully.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_OK,\n+\n+    /**\n+     * The group number passed did not designate a valid group.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_GROUP_NOT_FOUND,\n+\n+    /**\n+     * Message length exceeded TOX_MAX_MESSAGE_LENGTH.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_TOO_LONG,\n+\n+    /**\n+     * The message pointer is null or length is zero.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_EMPTY,\n+\n+    /**\n+     * The caller does not have the required permissions to send group messages.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_PERMISSIONS,\n+\n+    /**\n+     * The group is disconnected.\n+     */\n+    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_DISCONNECTED,\n+\n+} Tox_Err_Group_Send_Custom_Packet;\n+\n+\n+/**\n+ * Send a custom packet to the group.\n+ *\n+ * If lossless is true the packet will be lossless. Lossless packet behaviour is comparable\n+ * to TCP (reliability, arrive in order) but with packets instead of a stream.\n+ *\n+ * If lossless is false, the packet will be lossy. Lossy packets behave like UDP packets,\n+ * meaning they might never reach the other side or might arrive more than once (if someone\n+ * is messing with the connection) or might arrive in the wrong order.\n+ *\n+ * Unless latency is an issue or message reliability is not important, it is recommended that you use\n+ * lossless packets.\n+ *\n+ * The message length may not exceed TOX_MAX_CUSTOM_PACKET_SIZE. Larger packets",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r867232592",
            "id": 867232592,
            "line": 4515,
            "node_id": "PRRC_kwDOA7zIGs4zsOtQ",
            "original_commit_id": "b49c6bde7c2a6f24127fcd6af14e264d0296f2ca",
            "original_line": 4515,
            "original_position": 1246,
            "original_start_line": null,
            "path": "toxcore/tox.h",
            "position": 1249,
            "pull_request_review_id": 965211141,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/867232592/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-05-06T21:43:01Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/867232592",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2938071?v=4",
                "events_url": "https://api.github.com/users/Green-Sky/events{/privacy}",
                "followers_url": "https://api.github.com/users/Green-Sky/followers",
                "following_url": "https://api.github.com/users/Green-Sky/following{/other_user}",
                "gists_url": "https://api.github.com/users/Green-Sky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Green-Sky",
                "id": 2938071,
                "login": "Green-Sky",
                "node_id": "MDQ6VXNlcjI5MzgwNzE=",
                "organizations_url": "https://api.github.com/users/Green-Sky/orgs",
                "received_events_url": "https://api.github.com/users/Green-Sky/received_events",
                "repos_url": "https://api.github.com/users/Green-Sky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Green-Sky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Green-Sky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Green-Sky",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r874177000"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/874177000"
                }
            },
            "author_association": "MEMBER",
            "body": "missing `// 1`\r\nnot sure if that's important ",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-05-16T21:34:01Z",
            "diff_hunk": "@@ -0,0 +1,412 @@\n+/* SPDX-License-Identifier: GPL-3.0-or-later\n+ * Copyright Â© 2016-2020 The TokTok team.\n+ * Copyright Â© 2015 Tox project.\n+ */\n+\n+/**\n+ * Packer and unpacker functions for saving and loading groups.\n+ */\n+\n+#include \"group_pack.h\"\n+\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"bin_pack.h\"\n+#include \"bin_unpack.h\"\n+#include \"ccompat.h\"\n+#include \"util.h\"\n+\n+non_null()\n+static bool load_unpack_state_values(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 8)) {\n+        LOGGER_ERROR(chat->log, \"Group state values array malformed\");\n+        return false;\n+    }\n+\n+    bool manually_disconnected = false;\n+    uint8_t privacy_state = 0;\n+    uint8_t voice_state = 0;\n+\n+    if (!(bin_unpack_bool(bu, &manually_disconnected)\n+            && bin_unpack_u16(bu, &chat->shared_state.group_name_len)\n+            && bin_unpack_u08(bu, &privacy_state)\n+            && bin_unpack_u16(bu, &chat->shared_state.maxpeers)\n+            && bin_unpack_u16(bu, &chat->shared_state.password_length)\n+            && bin_unpack_u32(bu, &chat->shared_state.version)\n+            && bin_unpack_u32(bu, &chat->shared_state.topic_lock)\n+            && bin_unpack_u08(bu, &voice_state))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack state value\");\n+        return false;\n+    }\n+\n+    chat->connection_state = manually_disconnected ? CS_DISCONNECTED : CS_CONNECTING;\n+    chat->shared_state.privacy_state = (Group_Privacy_State)privacy_state;\n+    chat->shared_state.voice_state = (Group_Voice_State)voice_state;\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_state_bin(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 5)) {\n+        LOGGER_ERROR(chat->log, \"Group state binary array malformed\");\n+        return false;\n+    }\n+\n+    if (!(bin_unpack_bin_fixed(bu, chat->shared_state_sig, SIGNATURE_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.founder_public_key, EXT_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.group_name, chat->shared_state.group_name_len)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.password, chat->shared_state.password_length)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack state binary data\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_topic_info(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 6)) {\n+        LOGGER_ERROR(chat->log, \"Group topic array malformed\");\n+        return false;\n+    }\n+\n+    if (!(bin_unpack_u32(bu, &chat->topic_info.version)\n+            && bin_unpack_u16(bu, &chat->topic_info.length)\n+            && bin_unpack_u16(bu, &chat->topic_info.checksum)\n+            && bin_unpack_bin_fixed(bu, chat->topic_info.topic, chat->topic_info.length)\n+            && bin_unpack_bin_fixed(bu, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->topic_sig, SIGNATURE_SIZE))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack topic info\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_mod_list(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 2)) {\n+        LOGGER_ERROR(chat->log, \"Group mod list array malformed\");\n+        return false;\n+    }\n+\n+    if (!bin_unpack_u16(bu, &chat->moderation.num_mods)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack mod list value\");\n+        return false;\n+    }\n+\n+    if (chat->moderation.num_mods == 0) {\n+        return true;\n+    }\n+\n+    if (chat->moderation.num_mods > MOD_MAX_NUM_MODERATORS) {\n+        LOGGER_ERROR(chat->log, \"moderation count %u exceeds maximum %u\", chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);\n+        return false;\n+    }\n+\n+    uint8_t *packed_mod_list = (uint8_t *)malloc(chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE);\n+\n+    if (packed_mod_list == nullptr) {\n+        LOGGER_ERROR(chat->log, \"Failed to allocate memory for packed mod list\");\n+        return false;\n+    }\n+\n+    const size_t packed_size = chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE;\n+\n+    if (!bin_unpack_bin_fixed(bu, packed_mod_list, packed_size)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack mod list binary data\");\n+        free(packed_mod_list);\n+        return false;\n+    }\n+\n+    if (mod_list_unpack(&chat->moderation, packed_mod_list, packed_size, chat->moderation.num_mods) == -1) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack mod list info\");\n+        free(packed_mod_list);\n+        return false;\n+    }\n+\n+    free(packed_mod_list);\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_keys(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 4)) {\n+        LOGGER_ERROR(chat->log, \"Group keys array malformed\");\n+        return false;\n+    }\n+\n+    if (!(bin_unpack_bin_fixed(bu, chat->chat_public_key, EXT_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->chat_secret_key, EXT_SECRET_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->self_public_key, EXT_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->self_secret_key, EXT_SECRET_KEY_SIZE))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack keys\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_self_info(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 4)) {\n+        LOGGER_ERROR(chat->log, \"Group self info array malformed\");\n+        return false;\n+    }\n+\n+    uint8_t self_nick[MAX_GC_NICK_SIZE];\n+    uint16_t self_nick_len = 0;\n+    uint8_t self_role = GR_USER;\n+    uint8_t self_status = GS_NONE;\n+\n+    if (!(bin_unpack_u16(bu, &self_nick_len)\n+            && bin_unpack_u08(bu, &self_role)\n+            && bin_unpack_u08(bu, &self_status))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack self values\");\n+        return false;\n+    }\n+\n+    assert(self_nick_len <= MAX_GC_NICK_SIZE);\n+\n+    if (!bin_unpack_bin_fixed(bu, self_nick, self_nick_len)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack self nick bytes\");\n+        return false;\n+    }\n+\n+    // we have to add ourself before setting self info\n+    if (peer_add(chat, nullptr, chat->self_public_key) != 0) {\n+        LOGGER_ERROR(chat->log, \"Failed to add self to peer list\");\n+        return false;\n+    }\n+\n+    assert(chat->numpeers > 0);\n+\n+    GC_Peer *self = &chat->group[0];\n+\n+    memcpy(self->gconn.addr.public_key, chat->self_public_key, EXT_PUBLIC_KEY_SIZE);\n+    memcpy(self->nick, self_nick, self_nick_len);\n+    self->nick_length = self_nick_len;\n+    self->role = (Group_Role)self_role;\n+    self->status = (Group_Peer_Status)self_status;\n+    self->gconn.confirmed = true;\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_saved_peers(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 2)) {\n+        LOGGER_ERROR(chat->log, \"Group saved peers array malformed\");\n+        return false;\n+    }\n+\n+    // Saved peers\n+    uint16_t saved_peers_size = 0;\n+\n+    if (!bin_unpack_u16(bu, &saved_peers_size)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack saved peers value\");\n+        return false;\n+    }\n+\n+    if (saved_peers_size == 0) {\n+        return true;\n+    }\n+\n+    uint8_t *saved_peers = (uint8_t *)malloc(saved_peers_size * GC_SAVED_PEER_SIZE);\n+\n+    if (saved_peers == nullptr) {\n+        LOGGER_ERROR(chat->log, \"Failed to allocate memory for saved peer list\");\n+        return false;\n+    }\n+\n+    if (!bin_unpack_bin_fixed(bu, saved_peers, saved_peers_size)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack saved peers binary data\");\n+        free(saved_peers);\n+        return false;\n+    }\n+\n+    if (unpack_gc_saved_peers(chat, saved_peers, saved_peers_size) == -1) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack saved peers\");  // recoverable error\n+    }\n+\n+    free(saved_peers);\n+\n+    return true;\n+}\n+\n+bool gc_load_unpack_group(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 7)) {\n+        LOGGER_ERROR(chat->log, \"Group info array malformed\");\n+        return false;\n+    }\n+\n+    return load_unpack_state_values(chat, bu)\n+           && load_unpack_state_bin(chat, bu)\n+           && load_unpack_topic_info(chat, bu)\n+           && load_unpack_mod_list(chat, bu)\n+           && load_unpack_keys(chat, bu)\n+           && load_unpack_self_info(chat, bu)\n+           && load_unpack_saved_peers(chat, bu);\n+}\n+\n+non_null()\n+static void save_pack_state_values(const GC_Chat *chat, Bin_Pack *bp)\n+{\n+    bin_pack_array(bp, 8);\n+    bin_pack_bool(bp, chat->connection_state == CS_DISCONNECTED);",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r874177000",
            "id": 874177000,
            "line": null,
            "node_id": "PRRC_kwDOA7zIGs40GuHo",
            "original_commit_id": "d57ebf34fdf42b9851858bf75eb2a06300868937",
            "original_line": 270,
            "original_position": 270,
            "original_start_line": null,
            "path": "toxcore/group_pack.c",
            "position": null,
            "pull_request_review_id": 974593088,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/874177000/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-05-16T21:34:01Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/874177000",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2938071?v=4",
                "events_url": "https://api.github.com/users/Green-Sky/events{/privacy}",
                "followers_url": "https://api.github.com/users/Green-Sky/followers",
                "following_url": "https://api.github.com/users/Green-Sky/following{/other_user}",
                "gists_url": "https://api.github.com/users/Green-Sky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Green-Sky",
                "id": 2938071,
                "login": "Green-Sky",
                "node_id": "MDQ6VXNlcjI5MzgwNzE=",
                "organizations_url": "https://api.github.com/users/Green-Sky/orgs",
                "received_events_url": "https://api.github.com/users/Green-Sky/received_events",
                "repos_url": "https://api.github.com/users/Green-Sky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Green-Sky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Green-Sky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Green-Sky",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r874178288"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/874178288"
                }
            },
            "author_association": "MEMBER",
            "body": "array of size 2 and you fill in either 1 or 2, not sure this causes issues",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-05-16T21:36:02Z",
            "diff_hunk": "@@ -0,0 +1,412 @@\n+/* SPDX-License-Identifier: GPL-3.0-or-later\n+ * Copyright Â© 2016-2020 The TokTok team.\n+ * Copyright Â© 2015 Tox project.\n+ */\n+\n+/**\n+ * Packer and unpacker functions for saving and loading groups.\n+ */\n+\n+#include \"group_pack.h\"\n+\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"bin_pack.h\"\n+#include \"bin_unpack.h\"\n+#include \"ccompat.h\"\n+#include \"util.h\"\n+\n+non_null()\n+static bool load_unpack_state_values(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 8)) {\n+        LOGGER_ERROR(chat->log, \"Group state values array malformed\");\n+        return false;\n+    }\n+\n+    bool manually_disconnected = false;\n+    uint8_t privacy_state = 0;\n+    uint8_t voice_state = 0;\n+\n+    if (!(bin_unpack_bool(bu, &manually_disconnected)\n+            && bin_unpack_u16(bu, &chat->shared_state.group_name_len)\n+            && bin_unpack_u08(bu, &privacy_state)\n+            && bin_unpack_u16(bu, &chat->shared_state.maxpeers)\n+            && bin_unpack_u16(bu, &chat->shared_state.password_length)\n+            && bin_unpack_u32(bu, &chat->shared_state.version)\n+            && bin_unpack_u32(bu, &chat->shared_state.topic_lock)\n+            && bin_unpack_u08(bu, &voice_state))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack state value\");\n+        return false;\n+    }\n+\n+    chat->connection_state = manually_disconnected ? CS_DISCONNECTED : CS_CONNECTING;\n+    chat->shared_state.privacy_state = (Group_Privacy_State)privacy_state;\n+    chat->shared_state.voice_state = (Group_Voice_State)voice_state;\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_state_bin(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 5)) {\n+        LOGGER_ERROR(chat->log, \"Group state binary array malformed\");\n+        return false;\n+    }\n+\n+    if (!(bin_unpack_bin_fixed(bu, chat->shared_state_sig, SIGNATURE_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.founder_public_key, EXT_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.group_name, chat->shared_state.group_name_len)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.password, chat->shared_state.password_length)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack state binary data\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_topic_info(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 6)) {\n+        LOGGER_ERROR(chat->log, \"Group topic array malformed\");\n+        return false;\n+    }\n+\n+    if (!(bin_unpack_u32(bu, &chat->topic_info.version)\n+            && bin_unpack_u16(bu, &chat->topic_info.length)\n+            && bin_unpack_u16(bu, &chat->topic_info.checksum)\n+            && bin_unpack_bin_fixed(bu, chat->topic_info.topic, chat->topic_info.length)\n+            && bin_unpack_bin_fixed(bu, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->topic_sig, SIGNATURE_SIZE))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack topic info\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_mod_list(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 2)) {\n+        LOGGER_ERROR(chat->log, \"Group mod list array malformed\");\n+        return false;\n+    }\n+\n+    if (!bin_unpack_u16(bu, &chat->moderation.num_mods)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack mod list value\");\n+        return false;\n+    }\n+\n+    if (chat->moderation.num_mods == 0) {\n+        return true;\n+    }\n+\n+    if (chat->moderation.num_mods > MOD_MAX_NUM_MODERATORS) {\n+        LOGGER_ERROR(chat->log, \"moderation count %u exceeds maximum %u\", chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);\n+        return false;\n+    }\n+\n+    uint8_t *packed_mod_list = (uint8_t *)malloc(chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE);\n+\n+    if (packed_mod_list == nullptr) {\n+        LOGGER_ERROR(chat->log, \"Failed to allocate memory for packed mod list\");\n+        return false;\n+    }\n+\n+    const size_t packed_size = chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE;\n+\n+    if (!bin_unpack_bin_fixed(bu, packed_mod_list, packed_size)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack mod list binary data\");\n+        free(packed_mod_list);\n+        return false;\n+    }\n+\n+    if (mod_list_unpack(&chat->moderation, packed_mod_list, packed_size, chat->moderation.num_mods) == -1) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack mod list info\");\n+        free(packed_mod_list);\n+        return false;\n+    }\n+\n+    free(packed_mod_list);\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_keys(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 4)) {\n+        LOGGER_ERROR(chat->log, \"Group keys array malformed\");\n+        return false;\n+    }\n+\n+    if (!(bin_unpack_bin_fixed(bu, chat->chat_public_key, EXT_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->chat_secret_key, EXT_SECRET_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->self_public_key, EXT_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->self_secret_key, EXT_SECRET_KEY_SIZE))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack keys\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_self_info(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 4)) {\n+        LOGGER_ERROR(chat->log, \"Group self info array malformed\");\n+        return false;\n+    }\n+\n+    uint8_t self_nick[MAX_GC_NICK_SIZE];\n+    uint16_t self_nick_len = 0;\n+    uint8_t self_role = GR_USER;\n+    uint8_t self_status = GS_NONE;\n+\n+    if (!(bin_unpack_u16(bu, &self_nick_len)\n+            && bin_unpack_u08(bu, &self_role)\n+            && bin_unpack_u08(bu, &self_status))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack self values\");\n+        return false;\n+    }\n+\n+    assert(self_nick_len <= MAX_GC_NICK_SIZE);\n+\n+    if (!bin_unpack_bin_fixed(bu, self_nick, self_nick_len)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack self nick bytes\");\n+        return false;\n+    }\n+\n+    // we have to add ourself before setting self info\n+    if (peer_add(chat, nullptr, chat->self_public_key) != 0) {\n+        LOGGER_ERROR(chat->log, \"Failed to add self to peer list\");\n+        return false;\n+    }\n+\n+    assert(chat->numpeers > 0);\n+\n+    GC_Peer *self = &chat->group[0];\n+\n+    memcpy(self->gconn.addr.public_key, chat->self_public_key, EXT_PUBLIC_KEY_SIZE);\n+    memcpy(self->nick, self_nick, self_nick_len);\n+    self->nick_length = self_nick_len;\n+    self->role = (Group_Role)self_role;\n+    self->status = (Group_Peer_Status)self_status;\n+    self->gconn.confirmed = true;\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_saved_peers(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 2)) {\n+        LOGGER_ERROR(chat->log, \"Group saved peers array malformed\");\n+        return false;\n+    }\n+\n+    // Saved peers\n+    uint16_t saved_peers_size = 0;\n+\n+    if (!bin_unpack_u16(bu, &saved_peers_size)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack saved peers value\");\n+        return false;\n+    }\n+\n+    if (saved_peers_size == 0) {\n+        return true;\n+    }\n+\n+    uint8_t *saved_peers = (uint8_t *)malloc(saved_peers_size * GC_SAVED_PEER_SIZE);\n+\n+    if (saved_peers == nullptr) {\n+        LOGGER_ERROR(chat->log, \"Failed to allocate memory for saved peer list\");\n+        return false;\n+    }\n+\n+    if (!bin_unpack_bin_fixed(bu, saved_peers, saved_peers_size)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack saved peers binary data\");\n+        free(saved_peers);\n+        return false;\n+    }\n+\n+    if (unpack_gc_saved_peers(chat, saved_peers, saved_peers_size) == -1) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack saved peers\");  // recoverable error\n+    }\n+\n+    free(saved_peers);\n+\n+    return true;\n+}\n+\n+bool gc_load_unpack_group(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 7)) {\n+        LOGGER_ERROR(chat->log, \"Group info array malformed\");\n+        return false;\n+    }\n+\n+    return load_unpack_state_values(chat, bu)\n+           && load_unpack_state_bin(chat, bu)\n+           && load_unpack_topic_info(chat, bu)\n+           && load_unpack_mod_list(chat, bu)\n+           && load_unpack_keys(chat, bu)\n+           && load_unpack_self_info(chat, bu)\n+           && load_unpack_saved_peers(chat, bu);\n+}\n+\n+non_null()\n+static void save_pack_state_values(const GC_Chat *chat, Bin_Pack *bp)\n+{\n+    bin_pack_array(bp, 8);\n+    bin_pack_bool(bp, chat->connection_state == CS_DISCONNECTED);\n+    bin_pack_u16(bp, chat->shared_state.group_name_len); // 2\n+    bin_pack_u08(bp, chat->shared_state.privacy_state); // 3\n+    bin_pack_u16(bp, chat->shared_state.maxpeers); // 4\n+    bin_pack_u16(bp, chat->shared_state.password_length); // 5\n+    bin_pack_u32(bp, chat->shared_state.version); // 6\n+    bin_pack_u32(bp, chat->shared_state.topic_lock); // 7\n+    bin_pack_u08(bp, chat->shared_state.voice_state); // 8\n+}\n+\n+non_null()\n+static void save_pack_state_bin(const GC_Chat *chat, Bin_Pack *bp)\n+{\n+    bin_pack_array(bp, 5);\n+\n+    bin_pack_bin(bp, chat->shared_state_sig, SIGNATURE_SIZE); // 1\n+    bin_pack_bin(bp, chat->shared_state.founder_public_key, EXT_PUBLIC_KEY_SIZE); // 2\n+    bin_pack_bin(bp, chat->shared_state.group_name, chat->shared_state.group_name_len); // 3\n+    bin_pack_bin(bp, chat->shared_state.password, chat->shared_state.password_length); // 4\n+    bin_pack_bin(bp, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE); // 5\n+}\n+\n+non_null()\n+static void save_pack_topic_info(const GC_Chat *chat, Bin_Pack *bp)\n+{\n+    bin_pack_array(bp, 6);\n+\n+    bin_pack_u32(bp, chat->topic_info.version); // 1\n+    bin_pack_u16(bp, chat->topic_info.length); // 2\n+    bin_pack_u16(bp, chat->topic_info.checksum); // 3\n+    bin_pack_bin(bp, chat->topic_info.topic, chat->topic_info.length); // 4\n+    bin_pack_bin(bp, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE); // 5\n+    bin_pack_bin(bp, chat->topic_sig, SIGNATURE_SIZE); // 6\n+}\n+\n+non_null()\n+static void save_pack_mod_list(const GC_Chat *chat, Bin_Pack *bp)\n+{\n+    bin_pack_array(bp, 2);",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r874178288",
            "id": 874178288,
            "line": 315,
            "node_id": "PRRC_kwDOA7zIGs40Gubw",
            "original_commit_id": "d57ebf34fdf42b9851858bf75eb2a06300868937",
            "original_line": 315,
            "original_position": 308,
            "original_start_line": null,
            "path": "toxcore/group_pack.c",
            "position": 315,
            "pull_request_review_id": 974594785,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/874178288/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-05-16T21:38:20Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/874178288",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2938071?v=4",
                "events_url": "https://api.github.com/users/Green-Sky/events{/privacy}",
                "followers_url": "https://api.github.com/users/Green-Sky/followers",
                "following_url": "https://api.github.com/users/Green-Sky/following{/other_user}",
                "gists_url": "https://api.github.com/users/Green-Sky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Green-Sky",
                "id": 2938071,
                "login": "Green-Sky",
                "node_id": "MDQ6VXNlcjI5MzgwNzE=",
                "organizations_url": "https://api.github.com/users/Green-Sky/orgs",
                "received_events_url": "https://api.github.com/users/Green-Sky/received_events",
                "repos_url": "https://api.github.com/users/Green-Sky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Green-Sky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Green-Sky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Green-Sky",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r874180158"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269"
                },
                "self": {
                    "href": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/874180158"
                }
            },
            "author_association": "MEMBER",
            "body": "why binary pack if we could use an msgpack array?",
            "commit_id": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "created_at": "2022-05-16T21:39:00Z",
            "diff_hunk": "@@ -0,0 +1,412 @@\n+/* SPDX-License-Identifier: GPL-3.0-or-later\n+ * Copyright Â© 2016-2020 The TokTok team.\n+ * Copyright Â© 2015 Tox project.\n+ */\n+\n+/**\n+ * Packer and unpacker functions for saving and loading groups.\n+ */\n+\n+#include \"group_pack.h\"\n+\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"bin_pack.h\"\n+#include \"bin_unpack.h\"\n+#include \"ccompat.h\"\n+#include \"util.h\"\n+\n+non_null()\n+static bool load_unpack_state_values(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 8)) {\n+        LOGGER_ERROR(chat->log, \"Group state values array malformed\");\n+        return false;\n+    }\n+\n+    bool manually_disconnected = false;\n+    uint8_t privacy_state = 0;\n+    uint8_t voice_state = 0;\n+\n+    if (!(bin_unpack_bool(bu, &manually_disconnected)\n+            && bin_unpack_u16(bu, &chat->shared_state.group_name_len)\n+            && bin_unpack_u08(bu, &privacy_state)\n+            && bin_unpack_u16(bu, &chat->shared_state.maxpeers)\n+            && bin_unpack_u16(bu, &chat->shared_state.password_length)\n+            && bin_unpack_u32(bu, &chat->shared_state.version)\n+            && bin_unpack_u32(bu, &chat->shared_state.topic_lock)\n+            && bin_unpack_u08(bu, &voice_state))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack state value\");\n+        return false;\n+    }\n+\n+    chat->connection_state = manually_disconnected ? CS_DISCONNECTED : CS_CONNECTING;\n+    chat->shared_state.privacy_state = (Group_Privacy_State)privacy_state;\n+    chat->shared_state.voice_state = (Group_Voice_State)voice_state;\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_state_bin(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 5)) {\n+        LOGGER_ERROR(chat->log, \"Group state binary array malformed\");\n+        return false;\n+    }\n+\n+    if (!(bin_unpack_bin_fixed(bu, chat->shared_state_sig, SIGNATURE_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.founder_public_key, EXT_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.group_name, chat->shared_state.group_name_len)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.password, chat->shared_state.password_length)\n+            && bin_unpack_bin_fixed(bu, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack state binary data\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_topic_info(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 6)) {\n+        LOGGER_ERROR(chat->log, \"Group topic array malformed\");\n+        return false;\n+    }\n+\n+    if (!(bin_unpack_u32(bu, &chat->topic_info.version)\n+            && bin_unpack_u16(bu, &chat->topic_info.length)\n+            && bin_unpack_u16(bu, &chat->topic_info.checksum)\n+            && bin_unpack_bin_fixed(bu, chat->topic_info.topic, chat->topic_info.length)\n+            && bin_unpack_bin_fixed(bu, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->topic_sig, SIGNATURE_SIZE))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack topic info\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_mod_list(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 2)) {\n+        LOGGER_ERROR(chat->log, \"Group mod list array malformed\");\n+        return false;\n+    }\n+\n+    if (!bin_unpack_u16(bu, &chat->moderation.num_mods)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack mod list value\");\n+        return false;\n+    }\n+\n+    if (chat->moderation.num_mods == 0) {\n+        return true;\n+    }\n+\n+    if (chat->moderation.num_mods > MOD_MAX_NUM_MODERATORS) {\n+        LOGGER_ERROR(chat->log, \"moderation count %u exceeds maximum %u\", chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);\n+        return false;\n+    }\n+\n+    uint8_t *packed_mod_list = (uint8_t *)malloc(chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE);\n+\n+    if (packed_mod_list == nullptr) {\n+        LOGGER_ERROR(chat->log, \"Failed to allocate memory for packed mod list\");\n+        return false;\n+    }\n+\n+    const size_t packed_size = chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE;\n+\n+    if (!bin_unpack_bin_fixed(bu, packed_mod_list, packed_size)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack mod list binary data\");\n+        free(packed_mod_list);\n+        return false;\n+    }\n+\n+    if (mod_list_unpack(&chat->moderation, packed_mod_list, packed_size, chat->moderation.num_mods) == -1) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack mod list info\");\n+        free(packed_mod_list);\n+        return false;\n+    }\n+\n+    free(packed_mod_list);\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_keys(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 4)) {\n+        LOGGER_ERROR(chat->log, \"Group keys array malformed\");\n+        return false;\n+    }\n+\n+    if (!(bin_unpack_bin_fixed(bu, chat->chat_public_key, EXT_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->chat_secret_key, EXT_SECRET_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->self_public_key, EXT_PUBLIC_KEY_SIZE)\n+            && bin_unpack_bin_fixed(bu, chat->self_secret_key, EXT_SECRET_KEY_SIZE))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack keys\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_self_info(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 4)) {\n+        LOGGER_ERROR(chat->log, \"Group self info array malformed\");\n+        return false;\n+    }\n+\n+    uint8_t self_nick[MAX_GC_NICK_SIZE];\n+    uint16_t self_nick_len = 0;\n+    uint8_t self_role = GR_USER;\n+    uint8_t self_status = GS_NONE;\n+\n+    if (!(bin_unpack_u16(bu, &self_nick_len)\n+            && bin_unpack_u08(bu, &self_role)\n+            && bin_unpack_u08(bu, &self_status))) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack self values\");\n+        return false;\n+    }\n+\n+    assert(self_nick_len <= MAX_GC_NICK_SIZE);\n+\n+    if (!bin_unpack_bin_fixed(bu, self_nick, self_nick_len)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack self nick bytes\");\n+        return false;\n+    }\n+\n+    // we have to add ourself before setting self info\n+    if (peer_add(chat, nullptr, chat->self_public_key) != 0) {\n+        LOGGER_ERROR(chat->log, \"Failed to add self to peer list\");\n+        return false;\n+    }\n+\n+    assert(chat->numpeers > 0);\n+\n+    GC_Peer *self = &chat->group[0];\n+\n+    memcpy(self->gconn.addr.public_key, chat->self_public_key, EXT_PUBLIC_KEY_SIZE);\n+    memcpy(self->nick, self_nick, self_nick_len);\n+    self->nick_length = self_nick_len;\n+    self->role = (Group_Role)self_role;\n+    self->status = (Group_Peer_Status)self_status;\n+    self->gconn.confirmed = true;\n+\n+    return true;\n+}\n+\n+non_null()\n+static bool load_unpack_saved_peers(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 2)) {\n+        LOGGER_ERROR(chat->log, \"Group saved peers array malformed\");\n+        return false;\n+    }\n+\n+    // Saved peers\n+    uint16_t saved_peers_size = 0;\n+\n+    if (!bin_unpack_u16(bu, &saved_peers_size)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack saved peers value\");\n+        return false;\n+    }\n+\n+    if (saved_peers_size == 0) {\n+        return true;\n+    }\n+\n+    uint8_t *saved_peers = (uint8_t *)malloc(saved_peers_size * GC_SAVED_PEER_SIZE);\n+\n+    if (saved_peers == nullptr) {\n+        LOGGER_ERROR(chat->log, \"Failed to allocate memory for saved peer list\");\n+        return false;\n+    }\n+\n+    if (!bin_unpack_bin_fixed(bu, saved_peers, saved_peers_size)) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack saved peers binary data\");\n+        free(saved_peers);\n+        return false;\n+    }\n+\n+    if (unpack_gc_saved_peers(chat, saved_peers, saved_peers_size) == -1) {\n+        LOGGER_ERROR(chat->log, \"Failed to unpack saved peers\");  // recoverable error\n+    }\n+\n+    free(saved_peers);\n+\n+    return true;\n+}\n+\n+bool gc_load_unpack_group(GC_Chat *chat, Bin_Unpack *bu)\n+{\n+    if (!bin_unpack_array_fixed(bu, 7)) {\n+        LOGGER_ERROR(chat->log, \"Group info array malformed\");\n+        return false;\n+    }\n+\n+    return load_unpack_state_values(chat, bu)\n+           && load_unpack_state_bin(chat, bu)\n+           && load_unpack_topic_info(chat, bu)\n+           && load_unpack_mod_list(chat, bu)\n+           && load_unpack_keys(chat, bu)\n+           && load_unpack_self_info(chat, bu)\n+           && load_unpack_saved_peers(chat, bu);\n+}\n+\n+non_null()\n+static void save_pack_state_values(const GC_Chat *chat, Bin_Pack *bp)\n+{\n+    bin_pack_array(bp, 8);\n+    bin_pack_bool(bp, chat->connection_state == CS_DISCONNECTED);\n+    bin_pack_u16(bp, chat->shared_state.group_name_len); // 2\n+    bin_pack_u08(bp, chat->shared_state.privacy_state); // 3\n+    bin_pack_u16(bp, chat->shared_state.maxpeers); // 4\n+    bin_pack_u16(bp, chat->shared_state.password_length); // 5\n+    bin_pack_u32(bp, chat->shared_state.version); // 6\n+    bin_pack_u32(bp, chat->shared_state.topic_lock); // 7\n+    bin_pack_u08(bp, chat->shared_state.voice_state); // 8\n+}\n+\n+non_null()\n+static void save_pack_state_bin(const GC_Chat *chat, Bin_Pack *bp)\n+{\n+    bin_pack_array(bp, 5);\n+\n+    bin_pack_bin(bp, chat->shared_state_sig, SIGNATURE_SIZE); // 1\n+    bin_pack_bin(bp, chat->shared_state.founder_public_key, EXT_PUBLIC_KEY_SIZE); // 2\n+    bin_pack_bin(bp, chat->shared_state.group_name, chat->shared_state.group_name_len); // 3\n+    bin_pack_bin(bp, chat->shared_state.password, chat->shared_state.password_length); // 4\n+    bin_pack_bin(bp, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE); // 5\n+}\n+\n+non_null()\n+static void save_pack_topic_info(const GC_Chat *chat, Bin_Pack *bp)\n+{\n+    bin_pack_array(bp, 6);\n+\n+    bin_pack_u32(bp, chat->topic_info.version); // 1\n+    bin_pack_u16(bp, chat->topic_info.length); // 2\n+    bin_pack_u16(bp, chat->topic_info.checksum); // 3\n+    bin_pack_bin(bp, chat->topic_info.topic, chat->topic_info.length); // 4\n+    bin_pack_bin(bp, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE); // 5\n+    bin_pack_bin(bp, chat->topic_sig, SIGNATURE_SIZE); // 6\n+}\n+\n+non_null()\n+static void save_pack_mod_list(const GC_Chat *chat, Bin_Pack *bp)\n+{\n+    bin_pack_array(bp, 2);\n+\n+    const uint16_t num_mods = min_u16(chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);\n+\n+    if (num_mods == 0) {\n+        bin_pack_u16(bp, num_mods); // 1\n+        return;\n+    }\n+\n+    uint8_t *packed_mod_list = (uint8_t *)malloc(num_mods * MOD_LIST_ENTRY_SIZE);\n+\n+    // we can still recover without the mod list\n+    if (packed_mod_list == nullptr) {\n+        bin_pack_u16(bp, 0); // 1\n+        LOGGER_ERROR(chat->log, \"Failed to allocate memory for moderatin list\");\n+        return;\n+    }\n+\n+    bin_pack_u16(bp, num_mods); // 1\n+\n+    mod_list_pack(&chat->moderation, packed_mod_list);",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#discussion_r874180158",
            "id": 874180158,
            "line": 337,
            "node_id": "PRRC_kwDOA7zIGs40Gu4-",
            "original_commit_id": "d57ebf34fdf42b9851858bf75eb2a06300868937",
            "original_line": 337,
            "original_position": 328,
            "original_start_line": null,
            "path": "toxcore/group_pack.c",
            "position": 337,
            "pull_request_review_id": 974597281,
            "pull_request_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/874180158/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2022-05-16T21:39:00Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments/874180158",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2938071?v=4",
                "events_url": "https://api.github.com/users/Green-Sky/events{/privacy}",
                "followers_url": "https://api.github.com/users/Green-Sky/followers",
                "following_url": "https://api.github.com/users/Green-Sky/following{/other_user}",
                "gists_url": "https://api.github.com/users/Green-Sky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Green-Sky",
                "id": 2938071,
                "login": "Green-Sky",
                "node_id": "MDQ6VXNlcjI5MzgwNzE=",
                "organizations_url": "https://api.github.com/users/Green-Sky/orgs",
                "received_events_url": "https://api.github.com/users/Green-Sky/received_events",
                "repos_url": "https://api.github.com/users/Green-Sky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Green-Sky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Green-Sky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Green-Sky",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "\n\n\n\n\n*[`toxcore/group_pack.c` line 308 at r24](https://reviewable.io/reviews/toktok/c-toxcore/2269#-N-8ftbu5YEBl1-OH0E4-r24-308:-N2H1Wmp8-9H8Nyp0WbK:bh30n3p) ([raw file](https://github.com/toktok/c-toxcore/blob/d57ebf34fdf42b9851858bf75eb2a06300868937/toxcore/group_pack.c#L308)):*\n<details><summary><i>Previously, JFreegman wroteâ€¦</i></summary><blockquote>\n\nIf it caused issues it would produce an error when you tried to load a group with no mods since that would change the offset for the rest of the save file.\n</blockquote></details>\n\nIn any case it still means we produce non spec conforming msgpack.\ncmp works on token level, so it does not create a form of hierarchy, which makes the current code able to work, but no one else can parse this correctly.\n\n\n<!-- Sent from Reviewable.io -->\n",
            "created_at": "2022-05-17T12:51:00Z",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#issuecomment-1128829654",
            "id": 1128829654,
            "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/2269",
            "node_id": "IC_kwDOA7zIGs5DSJLW",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1128829654/reactions"
            },
            "updated_at": "2022-05-17T12:51:00Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1128829654",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2938071?v=4",
                "events_url": "https://api.github.com/users/Green-Sky/events{/privacy}",
                "followers_url": "https://api.github.com/users/Green-Sky/followers",
                "following_url": "https://api.github.com/users/Green-Sky/following{/other_user}",
                "gists_url": "https://api.github.com/users/Green-Sky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Green-Sky",
                "id": 2938071,
                "login": "Green-Sky",
                "node_id": "MDQ6VXNlcjI5MzgwNzE=",
                "organizations_url": "https://api.github.com/users/Green-Sky/orgs",
                "received_events_url": "https://api.github.com/users/Green-Sky/received_events",
                "repos_url": "https://api.github.com/users/Green-Sky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Green-Sky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Green-Sky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Green-Sky",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "\n\n\n\n\n*[`toxcore/tox.h` line 4378 at r25](https://reviewable.io/reviews/toktok/c-toxcore/2269#-N2M_sK0E8CN5KK9D_4t:-N2MbxLn1kMrFCoi4Q8o:b-kyrscz) ([raw file](https://github.com/toktok/c-toxcore/blob/8c8b32176785962e7d74449adbc12dba902e84db/toxcore/tox.h#L4378)):*\n<details><summary><i>Previously, Green-Sky (Erik Scholz) wroteâ€¦</i></summary><blockquote>\n\nIt says TOX_MAX_MESSAGE_LENGTH here, while in fact it checks against MAX_GC_MESSAGE_SIZE.\nsame for the other send functions.\n</blockquote></details>\n\nIgnore the suggestion, idk what happened there.\n\n\n<!-- Sent from Reviewable.io -->\n",
            "created_at": "2022-05-18T14:44:06Z",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#issuecomment-1130108901",
            "id": 1130108901,
            "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/2269",
            "node_id": "IC_kwDOA7zIGs5DXBfl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1130108901/reactions"
            },
            "updated_at": "2022-05-18T14:44:06Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1130108901",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2938071?v=4",
                "events_url": "https://api.github.com/users/Green-Sky/events{/privacy}",
                "followers_url": "https://api.github.com/users/Green-Sky/followers",
                "following_url": "https://api.github.com/users/Green-Sky/following{/other_user}",
                "gists_url": "https://api.github.com/users/Green-Sky/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Green-Sky",
                "id": 2938071,
                "login": "Green-Sky",
                "node_id": "MDQ6VXNlcjI5MzgwNzE=",
                "organizations_url": "https://api.github.com/users/Green-Sky/orgs",
                "received_events_url": "https://api.github.com/users/Green-Sky/received_events",
                "repos_url": "https://api.github.com/users/Green-Sky/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Green-Sky/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Green-Sky/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Green-Sky",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "# [Codecov](https://codecov.io/gh/TokTok/c-toxcore/pull/2269?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok) Report\n> Merging [#2269](https://codecov.io/gh/TokTok/c-toxcore/pull/2269?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok) (0a277b5) into [master](https://codecov.io/gh/TokTok/c-toxcore/commit/d3819b23b3bac6445cc1654e60530c86df3fb191?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok) (d3819b2) will **decrease** coverage by `0.77%`.\n> The diff coverage is `80.25%`.\n\n```diff\n@@            Coverage Diff             @@\n##           master    #2269      +/-   ##\n==========================================\n- Coverage   78.92%   78.15%   -0.78%     \n==========================================\n  Files         127      140      +13     \n  Lines       24109    31045    +6936     \n==========================================\n+ Hits        19029    24264    +5235     \n- Misses       5080     6781    +1701     \n```\n\n\n| [Impacted Files](https://codecov.io/gh/TokTok/c-toxcore/pull/2269?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok) | Coverage Î” | |\n|---|---|---|\n| [auto\\_tests/auto\\_test\\_support.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-YXV0b190ZXN0cy9hdXRvX3Rlc3Rfc3VwcG9ydC5j) | `82.35% <Ã¸> (+2.45%)` | :arrow_up: |\n| [other/DHT\\_bootstrap.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-b3RoZXIvREhUX2Jvb3RzdHJhcC5j) | `0.00% <0.00%> (Ã¸)` | |\n| [toxcore/TCP\\_common.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-dG94Y29yZS9UQ1BfY29tbW9uLmM=) | `78.51% <0.00%> (Ã¸)` | |\n| [toxcore/group\\_chats.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-dG94Y29yZS9ncm91cF9jaGF0cy5j) | `69.57% <Ã¸> (Ã¸)` | |\n| [toxcore/group\\_moderation.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-dG94Y29yZS9ncm91cF9tb2RlcmF0aW9uLmM=) | `80.15% <Ã¸> (-2.84%)` | :arrow_down: |\n| [toxcore/onion\\_announce.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-dG94Y29yZS9vbmlvbl9hbm5vdW5jZS5j) | `85.82% <Ã¸> (+5.15%)` | :arrow_up: |\n| [toxcore/tox\\_dispatch.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-dG94Y29yZS90b3hfZGlzcGF0Y2guYw==) | `49.00% <Ã¸> (Ã¸)` | |\n| [auto\\_tests/onion\\_test.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-YXV0b190ZXN0cy9vbmlvbl90ZXN0LmM=) | `82.36% <50.00%> (-3.51%)` | :arrow_down: |\n| [toxcore/tox.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-dG94Y29yZS90b3guYw==) | `64.11% <63.65%> (-0.55%)` | :arrow_down: |\n| [toxcore/group\\_pack.c](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok#diff-dG94Y29yZS9ncm91cF9wYWNrLmM=) | `65.67% <65.67%> (Ã¸)` | |\n| ... and [45 more](https://codecov.io/gh/TokTok/c-toxcore/pull/2269/diff?src=pr&el=tree-more&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok) | |\n\nHelp us with your feedback. Take ten seconds to tell us [how you rate us](https://about.codecov.io/nps?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok). Have a feature suggestion? [Share it here.](https://app.codecov.io/gh/feedback/?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=TokTok)\n",
            "created_at": "2022-05-27T13:56:30Z",
            "html_url": "https://github.com/TokTok/c-toxcore/pull/2269#issuecomment-1139644318",
            "id": 1139644318,
            "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/2269",
            "node_id": "IC_kwDOA7zIGs5D7Zee",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1139644318/reactions"
            },
            "updated_at": "2022-09-22T15:35:36Z",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/issues/comments/1139644318",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/in/254?v=4",
                "events_url": "https://api.github.com/users/codecov%5Bbot%5D/events{/privacy}",
                "followers_url": "https://api.github.com/users/codecov%5Bbot%5D/followers",
                "following_url": "https://api.github.com/users/codecov%5Bbot%5D/following{/other_user}",
                "gists_url": "https://api.github.com/users/codecov%5Bbot%5D/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/apps/codecov",
                "id": 22429695,
                "login": "codecov[bot]",
                "node_id": "MDM6Qm90MjI0Mjk2OTU=",
                "organizations_url": "https://api.github.com/users/codecov%5Bbot%5D/orgs",
                "received_events_url": "https://api.github.com/users/codecov%5Bbot%5D/received_events",
                "repos_url": "https://api.github.com/users/codecov%5Bbot%5D/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/codecov%5Bbot%5D/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/codecov%5Bbot%5D/subscriptions",
                "type": "Bot",
                "url": "https://api.github.com/users/codecov%5Bbot%5D",
                "user_view_type": "public"
            }
        }
    ],
    "comments": 3,
    "comments_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/2269/comments",
    "commit_data": [
        {
            "author": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1646057?v=4",
                "events_url": "https://api.github.com/users/JFreegman/events{/privacy}",
                "followers_url": "https://api.github.com/users/JFreegman/followers",
                "following_url": "https://api.github.com/users/JFreegman/following{/other_user}",
                "gists_url": "https://api.github.com/users/JFreegman/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/JFreegman",
                "id": 1646057,
                "login": "JFreegman",
                "node_id": "MDQ6VXNlcjE2NDYwNTc=",
                "organizations_url": "https://api.github.com/users/JFreegman/orgs",
                "received_events_url": "https://api.github.com/users/JFreegman/received_events",
                "repos_url": "https://api.github.com/users/JFreegman/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/JFreegman/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/JFreegman/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/JFreegman",
                "user_view_type": "public"
            },
            "comments_url": "https://api.github.com/repos/TokTok/c-toxcore/commits/0a277b52ea22fe297a8487ac05a0c507a74c6480/comments",
            "commit": {
                "author": {
                    "date": "2022-09-22T13:36:19Z",
                    "email": "jfreegman@gmail.com",
                    "name": "jfreegman"
                },
                "comment_count": 0,
                "committer": {
                    "date": "2022-09-22T15:16:08Z",
                    "email": "jfreegman@gmail.com",
                    "name": "jfreegman"
                },
                "message": "Merge the remainder of the new groupchats implementation\n\nCommit history: https://github.com/jfreegman/toxcore/tree/ngc_jf\nSpec: https://toktok.ltd/spec.html#dht-group-chats",
                "tree": {
                    "sha": "2f36e3622f961e3d306d80dfeefcbad96afe736a",
                    "url": "https://api.github.com/repos/TokTok/c-toxcore/git/trees/2f36e3622f961e3d306d80dfeefcbad96afe736a"
                },
                "url": "https://api.github.com/repos/TokTok/c-toxcore/git/commits/0a277b52ea22fe297a8487ac05a0c507a74c6480",
                "verification": {
                    "payload": "tree 2f36e3622f961e3d306d80dfeefcbad96afe736a\nparent d3819b23b3bac6445cc1654e60530c86df3fb191\nauthor jfreegman <jfreegman@gmail.com> 1663853779 -0400\ncommitter jfreegman <jfreegman@gmail.com> 1663859768 -0400\n\nMerge the remainder of the new groupchats implementation\n\nCommit history: https://github.com/jfreegman/toxcore/tree/ngc_jf\nSpec: https://toktok.ltd/spec.html#dht-group-chats\n",
                    "reason": "valid",
                    "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFIBAABCgAyFiEEur0AVzoGW/qQ1T1WNifzFEB2rmMFAmMsfDoUHGpmcmVlZ21h\nbkBnbWFpbC5jb20ACgkQNifzFEB2rmOFlwf/YhxqPzfm1SWkltAlWWdwzpOiu0I6\n9FbqlDgaWLVp1ZlLBc/d+AQppPgk6/bIXMVzq8nqdvqEPEaPC3tIL+aPurXdyyJh\n+b9I22e0heE3gj+gD1hmroU/xdJGoYPoSVSnXzSihZcfRHUAX9imDARMYk9s7+qW\nmev9r7q2fg8AVG2z8CHfffeHbh7+ApHpligMLAnXnCSY63OE8j4EeRQtyduRvXHQ\nzD0NS8vbRu6TKWf+iryeLrgfYX9xdKAdKn+QyMV4YuMq8AOra6teU98dnXp6muGU\n//TmRfqPq7vr29uyUsBQ58wLiAEvG0IA/U0UkHRzeKsdtNKuyhWtHPq1oQ==\n=QrJk\n-----END PGP SIGNATURE-----",
                    "verified": true,
                    "verified_at": "2024-11-06T18:12:47Z"
                }
            },
            "committer": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1646057?v=4",
                "events_url": "https://api.github.com/users/JFreegman/events{/privacy}",
                "followers_url": "https://api.github.com/users/JFreegman/followers",
                "following_url": "https://api.github.com/users/JFreegman/following{/other_user}",
                "gists_url": "https://api.github.com/users/JFreegman/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/JFreegman",
                "id": 1646057,
                "login": "JFreegman",
                "node_id": "MDQ6VXNlcjE2NDYwNTc=",
                "organizations_url": "https://api.github.com/users/JFreegman/orgs",
                "received_events_url": "https://api.github.com/users/JFreegman/received_events",
                "repos_url": "https://api.github.com/users/JFreegman/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/JFreegman/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/JFreegman/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/JFreegman",
                "user_view_type": "public"
            },
            "html_url": "https://github.com/TokTok/c-toxcore/commit/0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "node_id": "C_kwDOAQ6L0toAKDBhMjc3YjUyZWEyMmZlMjk3YTg0ODdhYzA1YTBjNTA3YTc0YzY0ODA",
            "parents": [
                {
                    "html_url": "https://github.com/TokTok/c-toxcore/commit/d3819b23b3bac6445cc1654e60530c86df3fb191",
                    "sha": "d3819b23b3bac6445cc1654e60530c86df3fb191",
                    "url": "https://api.github.com/repos/TokTok/c-toxcore/commits/d3819b23b3bac6445cc1654e60530c86df3fb191"
                }
            ],
            "sha": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/commits/0a277b52ea22fe297a8487ac05a0c507a74c6480"
        }
    ],
    "commits": 1,
    "commits_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269/commits",
    "created_at": "2022-04-08T14:58:56Z",
    "deletions": 123,
    "diff_url": "https://github.com/TokTok/c-toxcore/pull/2269.diff",
    "draft": false,
    "head": {
        "label": "JFreegman:ngc_merge",
        "ref": "ngc_merge",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/JFreegman/toxcore/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/JFreegman/toxcore/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/JFreegman/toxcore/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/JFreegman/toxcore/branches{/branch}",
            "clone_url": "https://github.com/JFreegman/toxcore.git",
            "collaborators_url": "https://api.github.com/repos/JFreegman/toxcore/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/JFreegman/toxcore/comments{/number}",
            "commits_url": "https://api.github.com/repos/JFreegman/toxcore/commits{/sha}",
            "compare_url": "https://api.github.com/repos/JFreegman/toxcore/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/JFreegman/toxcore/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/JFreegman/toxcore/contributors",
            "created_at": "2014-03-14T00:23:47Z",
            "default_branch": "ngc_merge",
            "deployments_url": "https://api.github.com/repos/JFreegman/toxcore/deployments",
            "description": "The future of online communications (new groupchats version)",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/JFreegman/toxcore/downloads",
            "events_url": "https://api.github.com/repos/JFreegman/toxcore/events",
            "fork": true,
            "forks": 3,
            "forks_count": 3,
            "forks_url": "https://api.github.com/repos/JFreegman/toxcore/forks",
            "full_name": "JFreegman/toxcore",
            "git_commits_url": "https://api.github.com/repos/JFreegman/toxcore/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/JFreegman/toxcore/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/JFreegman/toxcore/git/tags{/sha}",
            "git_url": "git://github.com/JFreegman/toxcore.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "http://tox.chat",
            "hooks_url": "https://api.github.com/repos/JFreegman/toxcore/hooks",
            "html_url": "https://github.com/JFreegman/toxcore",
            "id": 17730514,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/JFreegman/toxcore/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/JFreegman/toxcore/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/JFreegman/toxcore/issues{/number}",
            "keys_url": "https://api.github.com/repos/JFreegman/toxcore/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/JFreegman/toxcore/labels{/name}",
            "language": "C",
            "languages_url": "https://api.github.com/repos/JFreegman/toxcore/languages",
            "license": {
                "key": "gpl-3.0",
                "name": "GNU General Public License v3.0",
                "node_id": "MDc6TGljZW5zZTk=",
                "spdx_id": "GPL-3.0",
                "url": "https://api.github.com/licenses/gpl-3.0"
            },
            "merges_url": "https://api.github.com/repos/JFreegman/toxcore/merges",
            "milestones_url": "https://api.github.com/repos/JFreegman/toxcore/milestones{/number}",
            "mirror_url": null,
            "name": "toxcore",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNzczMDUxNA==",
            "notifications_url": "https://api.github.com/repos/JFreegman/toxcore/notifications{?since,all,participating}",
            "open_issues": 3,
            "open_issues_count": 3,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1646057?v=4",
                "events_url": "https://api.github.com/users/JFreegman/events{/privacy}",
                "followers_url": "https://api.github.com/users/JFreegman/followers",
                "following_url": "https://api.github.com/users/JFreegman/following{/other_user}",
                "gists_url": "https://api.github.com/users/JFreegman/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/JFreegman",
                "id": 1646057,
                "login": "JFreegman",
                "node_id": "MDQ6VXNlcjE2NDYwNTc=",
                "organizations_url": "https://api.github.com/users/JFreegman/orgs",
                "received_events_url": "https://api.github.com/users/JFreegman/received_events",
                "repos_url": "https://api.github.com/users/JFreegman/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/JFreegman/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/JFreegman/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/JFreegman",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/JFreegman/toxcore/pulls{/number}",
            "pushed_at": "2025-01-15T19:50:15Z",
            "releases_url": "https://api.github.com/repos/JFreegman/toxcore/releases{/id}",
            "size": 23096,
            "ssh_url": "git@github.com:JFreegman/toxcore.git",
            "stargazers_count": 29,
            "stargazers_url": "https://api.github.com/repos/JFreegman/toxcore/stargazers",
            "statuses_url": "https://api.github.com/repos/JFreegman/toxcore/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/JFreegman/toxcore/subscribers",
            "subscription_url": "https://api.github.com/repos/JFreegman/toxcore/subscription",
            "svn_url": "https://github.com/JFreegman/toxcore",
            "tags_url": "https://api.github.com/repos/JFreegman/toxcore/tags",
            "teams_url": "https://api.github.com/repos/JFreegman/toxcore/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/JFreegman/toxcore/git/trees{/sha}",
            "updated_at": "2024-10-25T16:07:26Z",
            "url": "https://api.github.com/repos/JFreegman/toxcore",
            "visibility": "public",
            "watchers": 29,
            "watchers_count": 29,
            "web_commit_signoff_required": false
        },
        "sha": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/1646057?v=4",
            "events_url": "https://api.github.com/users/JFreegman/events{/privacy}",
            "followers_url": "https://api.github.com/users/JFreegman/followers",
            "following_url": "https://api.github.com/users/JFreegman/following{/other_user}",
            "gists_url": "https://api.github.com/users/JFreegman/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/JFreegman",
            "id": 1646057,
            "login": "JFreegman",
            "node_id": "MDQ6VXNlcjE2NDYwNTc=",
            "organizations_url": "https://api.github.com/users/JFreegman/orgs",
            "received_events_url": "https://api.github.com/users/JFreegman/received_events",
            "repos_url": "https://api.github.com/users/JFreegman/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/JFreegman/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/JFreegman/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/JFreegman",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/TokTok/c-toxcore/pull/2269",
    "id": 903943545,
    "issue_url": "https://api.github.com/repos/TokTok/c-toxcore/issues/2269",
    "labels": [
        {
            "color": "84b6eb",
            "default": true,
            "description": "New feature for the user, not a new feature for build script",
            "id": 403702218,
            "name": "enhancement",
            "node_id": "MDU6TGFiZWw0MDM3MDIyMTg=",
            "url": "https://api.github.com/repos/TokTok/c-toxcore/labels/enhancement"
        }
    ],
    "locked": false,
    "maintainer_can_modify": false,
    "merge_commit_sha": "0a277b52ea22fe297a8487ac05a0c507a74c6480",
    "mergeable": null,
    "mergeable_state": "unknown",
    "merged": true,
    "merged_at": "2022-09-22T17:25:34Z",
    "merged_by": {
        "avatar_url": "https://avatars.githubusercontent.com/u/1646057?v=4",
        "events_url": "https://api.github.com/users/JFreegman/events{/privacy}",
        "followers_url": "https://api.github.com/users/JFreegman/followers",
        "following_url": "https://api.github.com/users/JFreegman/following{/other_user}",
        "gists_url": "https://api.github.com/users/JFreegman/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/JFreegman",
        "id": 1646057,
        "login": "JFreegman",
        "node_id": "MDQ6VXNlcjE2NDYwNTc=",
        "organizations_url": "https://api.github.com/users/JFreegman/orgs",
        "received_events_url": "https://api.github.com/users/JFreegman/received_events",
        "repos_url": "https://api.github.com/users/JFreegman/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/JFreegman/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/JFreegman/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/JFreegman",
        "user_view_type": "public"
    },
    "milestone": {
        "closed_at": "2024-03-28T01:32:29Z",
        "closed_issues": 284,
        "created_at": "2022-02-28T22:51:30Z",
        "creator": {
            "avatar_url": "https://avatars.githubusercontent.com/u/10647936?v=4",
            "events_url": "https://api.github.com/users/iphydf/events{/privacy}",
            "followers_url": "https://api.github.com/users/iphydf/followers",
            "following_url": "https://api.github.com/users/iphydf/following{/other_user}",
            "gists_url": "https://api.github.com/users/iphydf/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/iphydf",
            "id": 10647936,
            "login": "iphydf",
            "node_id": "MDQ6VXNlcjEwNjQ3OTM2",
            "organizations_url": "https://api.github.com/users/iphydf/orgs",
            "received_events_url": "https://api.github.com/users/iphydf/received_events",
            "repos_url": "https://api.github.com/users/iphydf/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/iphydf/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/iphydf/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/iphydf",
            "user_view_type": "public"
        },
        "description": "",
        "due_on": null,
        "html_url": "https://github.com/TokTok/c-toxcore/milestone/48",
        "id": 7722757,
        "labels_url": "https://api.github.com/repos/TokTok/c-toxcore/milestones/48/labels",
        "node_id": "MI_kwDOA7zIGs4AddcF",
        "number": 48,
        "open_issues": 0,
        "state": "closed",
        "title": "v0.2.19",
        "updated_at": "2024-03-28T15:26:26Z",
        "url": "https://api.github.com/repos/TokTok/c-toxcore/milestones/48"
    },
    "node_id": "PR_kwDOA7zIGs414RV5",
    "number": 2269,
    "patch_url": "https://github.com/TokTok/c-toxcore/pull/2269.patch",
    "rebaseable": null,
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/comments{/number}",
    "review_comments": 11,
    "review_comments_url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/TokTok/c-toxcore/statuses/0a277b52ea22fe297a8487ac05a0c507a74c6480",
    "title": "feat: Merge the remainder of the new groupchats implementation",
    "updated_at": "2022-09-22T17:25:34Z",
    "url": "https://api.github.com/repos/TokTok/c-toxcore/pulls/2269",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/1646057?v=4",
        "events_url": "https://api.github.com/users/JFreegman/events{/privacy}",
        "followers_url": "https://api.github.com/users/JFreegman/followers",
        "following_url": "https://api.github.com/users/JFreegman/following{/other_user}",
        "gists_url": "https://api.github.com/users/JFreegman/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/JFreegman",
        "id": 1646057,
        "login": "JFreegman",
        "node_id": "MDQ6VXNlcjE2NDYwNTc=",
        "organizations_url": "https://api.github.com/users/JFreegman/orgs",
        "received_events_url": "https://api.github.com/users/JFreegman/received_events",
        "repos_url": "https://api.github.com/users/JFreegman/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/JFreegman/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/JFreegman/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/JFreegman",
        "user_view_type": "public"
    }
}